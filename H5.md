# html

## 标签：

p：段落标签
h1-h6： 标题标签
b,strong： 加粗，一般使用strong
em,i： 斜体
big：变大
small：变小
marquee：设置文字滑动
sup：上标
sub：下标
del：删除
u：下划线
<br />：换行
<hr />：水平分割线
<meta charset="UTF-8">：设置字符集，防止中文乱码

## 列表：

无序列表，有序列表，自定义列表  列表可嵌套使用
无序列表：ul>li,  type类型有square正方形，circle空心圆，disc实心圆
有序列表：ol>li,  type类型有1，a，A，罗马数字
自定义列表：dl>dt+dd,  dt和dd并列

## 图片：img标签

```html
<img src="图片路径" alt="图片未加载成功时的提示文字" width="设置图片的宽度" height="设置图片的高度" title="鼠标悬停在图片上的提示文字" />
```

当设置图片的其中一边时，另一边也会等比例缩放

## html实体与锚链接：

a.html实体：&nbsp;空格
            &gt;大于号
            &lt;小于号
            &copy;版权
            &quot;引号
b.锚链接：
        第一种方法：
          <a href="" name="address"></a>
          <a href="#address">可跳转到name为address的位置</a>
        第二种方法：
          <p id="address"></p>
          <a href="#address">可跳转到id为address的位置</a>

## 超链接：a标签

<a href="点击该标签要跳转的地址" title="鼠标悬停在该标签上时出现的提示文字"></a>

## 表格：table标签

```html
<table border="表格边框" width="表格的宽度" height="表格的高度" cellpadding="单元格内边距" cellspacing="单元格之间的间距">
    <caption>设置表格的标题</caption>
    <tr>
        <th></th>
        <th></th>
    </tr>
    <tr>
        <td></td>
        <td></td>
    </tr>
    <!--colspan：列跨度
    rowspan：行跨度
    bgcolor：背景颜色
    background：设置背景图片
    align：对其方式  值为left，center，right-->
</table>
```

## form表单：

```html
<form action="页面信息提交的地址" methot="信息提交的方式">
    <input type="text" name="单行文本框" placeholder="文本框中的提示文字" autofocus />
    type表示表单的类型，name为其名字，placeholder为占位符，autofocus可使该文本框默认获取焦点
        表单的类型还有：password，email，radio，checkbox，file，image，hidden
        还有下拉列表：select>option
        多行文本框：textarea
        表单分组：fieldset>legend
    <input type="password" name="密码框" />
    <input type="radio" name="单选框" checked="checked"/>后跟选项内容   注意:在单选框中，每个选项的name必须一致
    <input type="checkbox" name="复选框" checked="checked" />
    <input type="file" name="文件域" /> 可从我的电脑中选取文件
    <input type="image" name="图像域" src="图像的路径" />图像域本身起到提交作用， 如果不给图像域src路径时，该图像域显示的是一个提交按钮
    <input type="hidden" name="隐藏域" /> 提交一些私密文件
    <textarea name="多行文本框"></textarea>
    <select name="下拉列表" size="">
        <option selected="selected">下拉列表1</option>
        <option>下拉列表2</option>
        <option>下拉列表3</option>
    </select>
    当给下拉列表设置size大于1的值时，其转变为列表框
    <fieldset name="表单分组">
        <legend>标题</legend>
        内容
    </fieldset>
</form>
```

## 行内元素与块级元素

- **行内元素：**a、b、span、img、input、strong、select、label、em、button、textarea；
- **块级元素：**div、ul、li、dl、dt、dd、p、h1-h6、blockquote；
- **空元素：**即系没有内容的HTML元素，例如：br、meta、hr、link、input、img。

# CSS

##     css选择器：

标签选择器，类选择器“.”，id选择器“#”，子代选择器“选择器>选择器”，后代选择器“选择器 选择器”，群组选择器，伪类选择器。

## 伪类选择器：

​		    link表示链接在没有被点击时的样式；
​                    visited表示链接在已经被访问时的样式；
                    hover表示当鼠标悬停在连接上面时的样式；
                    active表示被激活的元素，如被点击的链接、被按下时的按钮；
                    focus该伪类用于拥有键盘输入焦点的元素，一般应用于表单。

##     css常用属性：

###         字体属性：

​		color属性:设置文本的颜色
                        color:red;
                  font-family属性:设置元素的字体
                        font-family:"楷体";
                  font-size属性:设置字体大小
                        font-size:24px;
                  font-style属性:设置字体样式
                        font-style:normal; /*italic:斜体*/
                  font-weight属性:设置文本的粗细
                        font-style:normal; /*bold:文本加粗*/
                  line-height属性:设置行高
                        line-height:40px;

###         文本属性：

​		text-align属性:规定文本在块元素中的对齐方式
			 text-align:left; /*left:左对齐；right:右对齐；center:居中对齐；justify:两端对齐*/

​                  text-decoration属性:设置文本的修饰
                        text-decoration:none; /*underline:下划线；overline:上划线；line-through:删除线*/
                  text-indent属性:设置文本块中首行文本的缩进
                        text-indent:24px;
                  letter-spacing属性:设置字符间距
                        letter-spacing:20px;
                  word-spacing属性:设置单词间距
                        word-spacing:20px;
                  vertical-align:图片与文字的对齐方式，默认是基线对齐的
                        vertical-align:top; /*top:头部对齐；middle:中间对齐；bottom:底线对齐*/

​	border-collapse: collapse; 设置table表格边框为单线

### 	px和em的区别：

​	px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em

##         标签的类型：

​	在css中，html中的标签元素大体被分为三种不同的类型:

###                     块状元素(block)：

​			1.每个块元素都是从新的一行开始，并且其后的元素也另起一行。(一个块元素独占一行)；
           		2.元素的高度、宽度可设置；
                        3.元素在不设置宽度的时候，宽度为其父容器宽度的100%，除非设定一个宽度；
                        4.margin:0 auto;让一个有宽度，宽度不为100%的块级元素 居中对齐

###                     行内元素(inline)：

​				1.一行可以放多个；
                              2.元素的高度、宽度不可设置；
                              3.元素的宽度就是它包含的文字或图片（一般a标签里面可以包图片）的宽度，不可改变；
                              4.给包裹行内元素、行内块元素的元素添加text-align:center;可以让行内、行内块元素在该元素中居中。

###                     行内块元素(inline-block)：

```css
	// 设置行内块兼容写法
	display：inline-block；在IE低版本不兼容
  	*display：inline；
   	*zoom：1；
```

​	同时具备行内元素、块状元素的特点
              1.和其他元素都在一行上；
              2.元素的高度、宽度可设置
              3.当块级元素使用inline-block时，每个块之间会出现间隙，这是由于块元素转化为行内块时会存在1em的外边距，把父元素的font-size设置为0即可解决，之后还需给子元素设置字体大小。
                display:block;   将行内、行内块元素转为块
                display:inline;   将块元素转为行内（一般不将块元素转为行内元素）
                display:inline-block;  将块和行内元素转为行内块

​		当设置为inline-block时，可通过vertical-align：baseline;设置以基线对齐。

## 居中：

​	当让盒子里面的具有高度的li居中时，在给li父元素设置行高的同时，也要把li设置为行内块，这样，父元素的行高才会在li中生效。

​	让一个盒子居中显示：

1. 盒子宽高已知

   ```css
   	div {
               width: 200px;
               height: 200px;
               background-color: red;
               position: absolute;
               left: 50%;
               top: 50%;
               margin-top: -100px;
               margin-left: -100px;
           }
   ```

   

2. 盒子宽高未知

```css
	div {
            width: 200px;
            height: 200px;
            background-color: red;
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            margin: auto; /*可用于盒子宽高未知情况下使用，当把margin设置为auto时，盒子水平垂直居中
            当把margin设置为auto 0时，盒子垂直居中
            当吧margin设置为0 auto时，盒子水平居中*/
        }
```

## css之盒子模型

盒子的宽和高：宽和高可以给出具体的值，当不给宽和高时，宽度默认为父元素宽度的100%，高度为零；
              宽度的百分比写法，表示占父元素宽度的百分比，高度没有百分比；
              紧贴内容的左上角是宽高的起点(清除浏览器默认样式后)；
              行内元素设置宽高无效，除非转换为块元素或行内块元素。
边框属性：border-style:solid; /*盒子边框样式 solid:实线；dotted:点线；dashed:虚线；double:双线。*/
盒子内外边距：padding:内边距；margin:外边距。
            如果盒子有宽度和高度，再加padding值，则盒子一定会变大（不给盒子加box-sizing:border-box;）；
            如果盒子没有设置宽度，且默认宽度等于是父亲的宽度，则这个盒子，加padding并不影响盒子的宽度,只影响高度；
            一个盒子真实占有的宽度:等于width+左padding+右padding+左border+右border；
            一个盒子真实占有的高度:等于height+上padding+下padding+上border+下border；
            行内元素不支持上下的padding（能撑开高度但是不占位置，设置边框可测试）；
            margin:0 auto; 让一个有宽度，宽度不为100%的块级元素 居中对齐；
            块级元素 (div  h  p  ul  ol  li  dl  dt  dd)；
            margin:0 auto;对行内元素、行内块元素无效，除非转为块元素；
            给包裹行内元素、行内块元素的元素添加text-align:center可以让行内、行内块元素在该元素中居中行内元素不支持上下的margin

## 背景属性

​     background-color:#000; 设置背景颜色
     background-image:url(images/bg.jpg); 设置背景图像
     background-repeat:no-repeat; 设置图像平铺方式 /*no-repeat:不平铺；repeat-x:水平平铺；repeat-y:垂直平铺；repeat:平铺。默认平铺*/
     background-position:1px 3px; 背景图像开始显示的位置/*对应水平垂直位置，可以使用数值单位或%，也可以是关键字*/
     background-attachment:fixed; 设置背景图片不随浏览器的滚动而滚动

​	背景复合属性：background: 颜色 背景图片 水平位置 垂直位置  设置平铺；

## css之浮动

​     布局模型与盒模型一样都是CSS最基本、最核心的概念，但布局模型是建立在盒模型基础之上。
     CSS包含3种基本的布局模型：
         -流动模型（flow）
         -浮动模型（float）
         -层模型（layout）:定位
     流动模型是默认的网页布局模式。
         也就是说网页在默认状态下的HTML网页元素都是根据流动模型来分布网页内容的。
         块状元素都会在所处的包含元素自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置（占整行）。
         在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（一行放多个）
     浮动：
         float:属性定义元素在哪个方向浮动
                 其值有left，right，none。
             任何元素都可以浮动；
             一个盒子里面有一个元素浮动，其他的都得浮动。
         浮动的特性：
             浮动元素回去找离他最近的有浮动的元素边贴；
             假如一行之上只有极少的空间可供浮动元素，那么这个元素会跳至下一行；
             右浮动会颠倒盒子顺序；
             行内显示模式的标签加了浮动后，可以直接设置宽高，无需转换；
             块显示模式的元素，如果没有设置宽高，添加了浮动后，会收缩到内容的大小；
             浮动元素会脱离文档流，会压住下一个块元素，但不会压住其内容。

##  清除浮动：

​             法1: 定高法
                 给浮动元素的父元素设置高度大于或等于最高的浮动元素的高度。用于小版块，高度可以写死的部分。
             法2: 额外标签法
                 给并列浮动元素加一个额外的标签用clear:both;清除浮动。
             法3: 给浮动元素的父元素加overflow:hidden;
             法4: 利用after伪元素清除浮动

```css
			 .clearfix:after {
                     content: ""; /*必写属性*/
                     display: block; 
                     heigth: 0;
                     clear: both;
                     visibility: hidden; /*隐藏*/
                 }
                 .clearfix {
                     zoom: 1; /*为了兼容低版本ie浏览器*/
                 }
```


​         浮动注意事项：
             同级的元素，要么全部浮动，要么全部不浮动；
             子元素浮动，父元素去清除浮动: 如果父元素也浮动，寻找距离最近的没有浮动的祖先元素去做清除浮动的操作；
             父元素有绝对定位不需要清除浮动。

##  定位：

​        子绝父相 

​	定位属性有相对定位、绝对定位和固定定位；
         相对定位(relative):相对于它正常文档流的位置进行定位；
         绝对定位(absolute):这条语句的作用将元素从文档流中脱离出来，然后通过left、top、right、bottom属性相对于其最近的一个具有定位属性的祖先元素进行绝对定位。如果不存在这样的元素，则相对于body元素。

​     绝对定位的元素完全脱离标准流(在文档流中不占位置)。它完全漂浮于标准流的上方。相对定位在文档流中是占有位置的。不管怎样移动，原来的位置保留，根据这个特点，一般使用  子元素绝对定位，父元素相对定位。

​     z-index属性：规定元素的堆叠顺序，仅在定位元素上有效。只有设置定位之后才能设置z-index属性

## before与after

:before 伪元素在元素之前添加内容。

​	这个伪元素允许创作人员在元素内容的最前面插入生成内容。默认地，这个伪元素是行内元素，不过可以使用属性 display 改变这一点。、

:after 伪元素在元素之后添加内容。

​	这个伪元素允许创作人员在元素内容的最后面插入生成内容。默认地，这个伪元素是行内元素，不过可以使用属性 display 改变这一点。

## 设置max-height,min-height,max-width,min-width

​	这些属性与height和width不同，当设置height时，未固定高度，而max-height只是设置最大的高度，当容器里面的内容没有max-height大时，则容器高度和内容一样，当内容超过容器最大高度时，容器高度不再变化。为设置的最大高度。

## 取消蓝色边框

outline: none;  /*取消元素获取焦点时的蓝色边框*/

## CSS3之盒子模型

给盒子设置box-sizing:border-box;即将盒子设置为固定大小，设置padding不影响盒子大小。

CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。

可以分成两种情况：

1、box-sizing: content-box  盒子大小为 width + padding + border   content-box:此值为其默认值，其让元素维持W3C的标准Box Mode

2、box-sizing: border-box  盒子大小为 width    就是说  padding 和 border 是包含到width里面的

注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。

```css
div:first-child {
			width: 200px;
			height: 200px;
			background-color: pink; 
			box-sizing: content-box;  /*  就是以前的标准盒模型  w3c */
			padding: 10px;
			border: 15px solid red;
			/* 盒子大小为 width + padding + border   content-box:此值为其默认值，其让元素维持W3C的标准Box Mode */
		}
		div:last-child {
			width: 200px;
			height: 200px;
			background-color: purple;
			padding: 10px;
			box-sizing: border-box;   /* padding border  不撑开盒子 */
			border: 15px solid red;
			/* margin: 10px; */
			/* 盒子大小为 width    就是说  padding 和 border 是包含到width里面的 */
}
```

## CSS用户界面样式

- **鼠标样式cursor**

设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 

```css
cursor :  default  小白 | pointer  小手  | move  移动  |  text  文本
```

- **轮廓outline**

 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。

```css
 outline : outline-color ||outline-style || outline-width 
```

- **防止拖拽文本域resize**

resize：none    这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。

右下角可以拖拽： 

<textarea></textarea>

右下角不可以拖拽： 

```html
<textarea  style="resize: none;"></textarea>
```

- **vertical-align 垂直对齐**

以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto;

以前我们还讲过让文字居中对齐，是 text-align: center;

```css
vertical-align : baseline |top |middle |bottom 
```

设置或检索对象内容的垂直对其方式。 

vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， **通常用来控制图片/表单与文字的对齐**。

- **图片、表单和文字对齐**

所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。

- **去除图片底侧空白缝隙**

有个很重要特性你要记住： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。这样会造成一个问题，就是图片底侧会有一个空白缝隙。

解决的方法就是：  

1. 给img vertical-align:middle | top等等。  让图片不要和基线对齐。

1. 给img 添加 display：block; 转换为块级元素就不会存在问题了。

## opacity设置透明

```css
opacity:0.5;  //属性值0-1,0为全透明，1为不透明。
Filter：alpha（opacity=50); //兼容写法，50与opacity中的0.5相对应
```

## 溢出的文字隐藏

### white-space

white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 
normal : 　默认处理方式
nowrap : 　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。可以处理中文

### text-overflow 文字溢出

text-overflow : clip | ellipsis

设置或检索是否使用一个省略标记（...）标示对象内文本的溢出

clip : 　不显示省略标记（...），而是简单的裁切 

ellipsis : 　当对象内文本溢出时显示省略标记（...）

注意一定要首先强制一行内显示，再次和overflow属性  搭配使用

## 精灵图（sprite）

​	减轻服务器压力，减少服务器请求次数。

​	background-position: 0 0;  //背景定位

## ico图标

### 引入ico图标

```html
代码：  <link rel="shortcut icon" href="favicon.ico"  type="image/x-icon"/>     
```

注意： 

1. 它不是iconfont字体, 也不是图片。
2. 位置是放到 head 标签中间。
3. 后面的type="image/x-icon"  属性可以省略。
4. 为了兼容性，请将favicon.ico 这个图标放到根目录下。
5. 查看一个网站的ico，网址/favicon.ico

### 转换ico图标

我们可以自己做的图片，转换为 ico图标，以便放到我们站点里面。 http://www.bitbug.net/

## 字体图标

图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的"http请求"，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新"宠幸"啦。。 这就是字体图标（iconfont).

### 字体图标优点

```html
可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..
但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...
本身体积更小，但携带的信息并没有削减。
几乎支持所有的浏览器
移动端设备必备良药...
```

### 字体图标使用流程

总体来说，字体图标按照如下流程：

#### 设计字体图标

假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图：

  之后保存为svg格式，然后给我们前端人员就好了。 

  其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。

#### 上传生成字体包

   当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。

​    推荐网站： http://icomoon.io

**icomoon字库**

IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。

   推荐网站： http://www.iconfont.cn/

**阿里icon font字库**

http://www.iconfont.cn/

这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！

**fontello**

[http://fontello.com/](http://fontello.com/)

在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。

**Font-Awesome**

[http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/)

这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。

**Glyphicon Halflings**

[http://glyphicons.com/](http://glyphicons.com/)

这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。

**Icons8**

[https://icons8.com/](https://icons8.com/)

提供PNG免费下载，像素大能到500PX

#### 下载兼容字体包

刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了

当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。

#### 字体引入到HTML

得到压缩包之后，最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。

1. 首先把 以下4个文件放入到 fonts文件夹里面。 通俗的做法

   ##### 第一步：在样式里面声明字体： 告诉别人我们自己定义的字体

   ```css
   @font-face {
     font-family: 'icomoon';
     src:  url('fonts/icomoon.eot?7kkyc2');
     src:  url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
       url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
       url('fonts/icomoon.woff?7kkyc2') format('woff'),
       url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg');
     font-weight: normal;
     font-style: normal;
   }
   ```

   ##### 第二步：给盒子使用字体

   ```css
   span {
   		font-family: "icomoon";
   	}
   ```

   ##### 第三步：盒子里面添加结构

   ```css
   span::before {
   		 content: "\e900";
   	}
   或者  
   <span></span>  
   ```

   #### 追加新图标到原来库里面

   如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标，但是原来的不能删除，继续使用，此时我们需要这样做

   把压缩包里面的selection.json 从新上传，然后，选中自己想要新的图标，从新下载压缩包，替换原来文件即可。

### 网站优化三大标签

SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”！SEO是指通过对网站进行站内优化、网站结构调整、网站内容建设、网站代码优化等)和站外优化，从而提高网站的关键词排名以及公司产品的曝光度。 简单的说就是，把产品做好，搜索引擎就会介绍客户来。  

 我们现在阶段主要进行站内优化。网站优化，我们应该要懂。。。

#### 网页title 标题

​	title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。
建议：
	首页标题：网站名（产品名）- 网站的介绍    
例如：
	京东(JD.COM)-综合网购首选-正品低价、品质保障、配送及时、轻松购物！
小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站

#### Description  网站说明

对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。
我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。

京东网：

```html
<meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!" />
```

注意点：

1. 描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。
2. 同样遵循简短原则，字符数含空格在内不要超过 120  个汉字。
3. 补充在 title  和 keywords  中未能充分表述的说明.
4. 用英文逗号 关键词1,关键词2

```html
<meta name="description" content="小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。" />
```

#### Keywords 关键字

Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。

京东网：

```html
<meta name="Keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东" />
```

小米网：

```html
<meta name="keywords" content="小米,小米6,红米Note4,小米MIX,小米商城" />
```

## css3之变换(Transform)

### 2D变换

### 移动translate()方法

​	通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数： 

​	值 translate(50px,100px) 把元素从左侧移动 50 像素，从顶端移动 100 像素。

### 旋转rotate()方法

​	通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 

​	值 rotate(30deg) 把元素顺时针旋转 30 度。 

### 缩放scale()方法

​	通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数： 

​	值 scale(2,4) 把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。 

### 倾斜skew()方法

​	通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数： 

​	值 skew(30deg,20deg) 围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度。 

### 组合属性matrix()方法

​	matrix() 方法把所有 2D 转换方法组合在一起。

​	matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素。

### transform-origin属性可以调整元素转换变形的原点

```html
div{transform-origin: left top;transform: rotate(45deg); }  /* 改变元素原点到左上角，然后进行顺时旋转45度 */    
```

​	 如果是4个角，可以用 left top这些，如果想要精确的位置， 可以用  px 像素。

```html
 div{transform-origin: 10px 10px;transform: rotate(45deg); }  /* 改变元素原点到x 为10  y 为10，然后进行顺时旋转45度 */ 
```

## 3D变换

### 3D动画实现步骤

1. 舞台（stage）：设置perspective：1000px; 一般设置为1000px;
2. 容器（cont）：设置transform-style: preserve-3d; 
3. 设置要变换的元素。

### rotateX()方法

​	通过 rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转。 

### rotateY()方法

​	通过 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转。 

### rotateZ()方法

​	通过 rotateZ() 方法，元素围绕其 Z轴以给定的度数进行旋转。 

### 透视(perspective)

电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。

透视可以将一个2D平面，在转换的过程当中，呈现3D效果。

- 透视原理： 近大远小 。
- 浏览器透视：把近大远小的所有图像，透视在屏幕上。
- perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置

注：并非任何情况下需要透视效果，根据开发需要进行设置。

perspective 一般作为一个属性，设置给父元素，作用于所有3D转换的子元素

### translateX(x)

​	仅水平方向移动**（X轴移动）

​	主要目的实现移动效果

### translateY(y)

​	仅垂直方向移动（Y轴移动）

### translateZ(z)

​	transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。

### translate3d(x,y,z)

​	[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值

### backface-visibility

​	backface-visibility 属性定义当元素不面向屏幕时是否可见。

## 动画(CSS3) animation

​	动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。

语法格式：

```
animation:动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;
```

## css3之渐变(Transition)

​	transition：设置渐变

​		transition: 要过渡的属性  花费时间  运动曲线  何时开始;
				如果有多组属性变化，还是用逗号隔开。

​		有四个属性：property  规定应用过渡的css属性的名称；

​					duration 定义过渡效果发费的时间；

​					timing-function 定义过渡效果的时间曲线；

​					delay 规定过渡效果何时开始。

| 属性                       | 描述                                         | CSS  |
| -------------------------- | -------------------------------------------- | ---- |
| transition                 | 简写属性，用于在一个属性中设置四个过渡属性。 | 3    |
| transition-property        | 规定应用过渡的 CSS 属性的名称。              | 3    |
| transition-duration        | 定义过渡效果花费的时间。默认是 0。           | 3    |
| transition-timing-function | 规定过渡效果的时间曲线。默认是 "ease"。      | 3    |
| transition-delay           | 规定过渡效果何时开始。默认是 0。             | 3    |

​	如果想要所有的属性都变化过渡， 写一个all 就可以	

​	transition在与display：block；同时使用时，display会使transition失效。

## css3浏览器兼容

```css
	-ms-		/* IE 9 */
	-moz-	/* Firefox */
	-webkit-	/* Safari and Chrome */
	-o-		/* Opera */
```

```css
/* IE7认识 */
selector{+property:value;}
/* IE8认识 */
selector{+property:value\0;}
/* IE6 & IE7认识 */
selector{*property:value;}
/* IE6 & IE7 & IE8认识 */
selector{property:value\9;}
```

## css3之弹性盒子

### 盒子模型

​	**padding+border+content**

- 标准浏览器中，盒子模型的宽=content的宽
- IE浏览器中，盒子模型的宽=content+padding+border

### 伸缩布局：FlexBox

1. CSS3为display属性增加了一个新值flex，于是flexbox布局诞生了；
2. flexbox布局的优点是可以根据需要自动修改弹性容器内项目的间距和大小；
3. 可以在不借助任何框架的情况下，只用短短几行代码就实现响应式布局（项目宽度可以自适应）；
4. 对于一个盒子容器，它的子元素既可以沿X轴（主轴）排列，也可以沿Y轴（副轴、侧轴）排列。

### 盒子容器属性

#### flex-direction属性

决定主轴的方向，即项目排列方向
语法：flex-direction:row  | row-reverse | column | column-reverse;

- row（默认值）：主轴为水平方向，起点在左端；
- row-reverse：主轴为水平方向，起点在右端；
- column：主轴为垂直方向，起点在上沿；
- column-reverse：主轴为垂直方向，起点在下沿。

#### flex-wrap属性

定义是否允许换行
语法：flex-wrap: nowrap | wrap | wrap-reverse

- noewrap（默认值）：弹性容器为单行。该情况下子项可能会溢出容器；
- wrap：弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行；
- wrap-reverse：反转wrap排列。

注意：

（1）如果项目横排，且项目无width属性时，项目宽度和内容宽度相同；

（2）给项目设置width属性时，项目总宽少于容器的时候，会按width设置，项目总宽超出容器时，因为默认不换行，宽度自适应（评分宽度）；

（3）设置换行，则宽度还按width设置的显示。

#### justify-content属性

定义了项目在主轴上的对齐方式
语法：justify-content: flex-start  |  flex-end  |  center  |  space-between  |  space-around

- flex-start（默认值）：表示相对于主轴起点对齐；
- flex-end：表示相对于主轴终点对齐；
- center：居中对齐。（如果剩余的只有空间是负的，则弹性项目将在两个方向上同时溢出）。
- space-between：表示两端对齐并将剩余空间在主轴方向上进行平均分配（首尾项目贴边）。
- space-around：表示居中对齐然后在主轴方向上将剩余空间平均分配（首尾项目和边界之间有空白）。

#### align-items属性

表示可伸缩项目在侧轴方向上的对齐方式（每行子元素的对齐方式）
语法：align-items : flex-start  |  flex-end  |  center  |  baseline  |  stretch

- flex-start：表示行顶端为起点；
- flex-end：表示行地端为起点；
- center：居中对齐；
- baseline：以文字基线对齐；
- stretch（默认值）：如果容器项目没有设置高度，则采用stretch，所有项目都和最高的一样。如果项目有高度，则显示为flex-start。

#### flex-flow属性

1、flex-flow属性是flex-direction属性和flex-wrap属性的简写形式；

2、默认值为 row nowrap。

#### align-content属性

当进行多行布局时，可以使用align-content属性来指定各行之间的对齐方式。
语法： align-content : flex-start | flex-end | center | space-between | space-around | stretch。
align-content属性用于指定行对齐方式,   而align-items属性用于指定子元素的对齐方式。

- flex-start：从cross（侧轴）-start开始布局所有行；
- flex-end：从cross-end开始布局所有行；
- center：居中布局所有行；
- space-between：均分行之间的空白；
- space-around：均分每行两侧空白；
- stretch：默认值。当子元素没有指定高度时，则采用此设定，扩展高度填满父元素。

### 盒子项目属性

#### align-self属性 （添加在伸缩项目上）

1. 该属性是给各个可伸缩项设置自己的在侧轴上的对齐方式的。
2. 之前在容器上设置的align-item属性是作为一个整体设置的，所有的元素对齐方式都一样。
3. align-self属性会覆盖之前的align-item属性，让每个可伸缩项在侧轴上具有不同的对齐方式。设置align-self时，不要在伸缩容器中设置align-item。
4. 语法： align-self :    flex-start | flex-end | center  | baseline | stretch
5. align-content属性用于指定行对齐方式,   而align-items属性用于指定子元素的对齐方式默认值为: stretch。

#### order属性

1. order属性控制元素在布局中出现的顺序。(添加在伸缩项目上，针对所有行的项目进行排序 )；
2. 语法：  order: -1;
3. 该属性默认值是0，可以为负数，值小的排在前面，值大的排在后面；
4. 可以把几个元素的order设为同一个数，这样的话它们会根据在HTML结构中出现的顺序排列。

#### margin属性

​	如果给某个可伸缩项设置某个方向上的margin为auto，那么这个可伸缩项就会在这个方向上占用该方向的剩余空间来作为自己的这个方向上的margin。

#### flex属性

一般有两种使用方法（添加在伸缩项目)：

1、设所有伸缩项目 flex: 1；这样所有子元素的总宽度等于容器宽度（原来多行会变一行）。

2、在所有flex: 1； 的基础上，可以给个别子元素单独设置 flex : 2,这样该元素宽度是其它元素的2倍。

#### flex-basis属性

```css
flex-basis: 200px;//会覆盖项目之前设置的宽度
```

#### flex-grow属性，flex-shrink属性

​	可以使用flex-grow属性来指定元素宽度，但是该样式属性对于元素宽度的计算方法与flex样式属性对于元素宽度的计算方法有所不同。（添加在伸缩项目上）

（1）当给所有伸缩项目设置 flex-grow : 1 ，并且允许换行时，则每行内项目均分宽度，填满整行。

（2）如果项目本身有宽度，则参考此宽度决定是否换行，而因为有flex-grow:1,则自动调整最终宽度，填满整行。

（3）如果不允许换行，则可以选择用flex-grow 或flex-shrink。

​	a. 当子元素的width样式属性值的总和小于容器元素的宽度值时，必须通过flex-grow样式属性来调整子元素宽度;

​	b.当子元素的width样式属性值的总和大于容器元素的宽度值时，必须通过flex-shrink样式属性来调整子元素宽度。

## css3之响应式网页设计

### 响应式网页设计

1. 响应式Web设计（Responsive Web design）：即RWD网页设计；
2. 响应式Web设计的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（屏幕类型、屏幕尺寸、屏幕定向等）进行相对应的布局；
3. 四种网页布局形式
   a、静态布局；b、流式布局；c、自适应布局；d、响应式布局。

### 配置viewport（视角口）

顾名思义，响应式页面要对PC端与手机端进行自适应页面转换，所以要保持比例一致，在html页面中添加以下代码。

```html
<meta name="viewport" content="width=device-width,initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
```

### 媒体查询（Media queries）

媒体查询就是为了使我们可以在不同的页面节点设置不同的样式，实现响应式布局。

#### 嵌入媒体查询的方法

```html
// 通过外部连接方式，网页小于等于480可视化窗口的时候调用了mobile.css的样式
<link rel=“stylesheet” media=“(max-width:480px)” href=“mobile.css”>
// 也可以总结写在当前页面中
@media (max-width:480px){
        body{
	background:red;
        }
}
```

#### 设备方向（Orientation）

```html
// 设置垂直方向的样式
@media(orientation:portrait){...}
//设置水平方向的样式
@media(orientation:landscape){...}
// 不仅仅是手机的横屏竖屏，放大缩小浏览器也生效
```

#### 宽度与高度的具体设定

width与device-width  可视宽度与设备宽度
@media(max-width:480px){ … }
浏览器的宽度在小于等于480px的时候的样式
@media(max-device-width:480px){ … }
设备宽度(就是手机的逻辑像素)在小于等于480px的时候的样式

height与device-height  可视宽度与设备宽度
@media(max-height:480px){ … }
浏览器的高度在小于等于480px的时候的样式
@media(max-device-height:480px){ … }
设备高度(就是手机的逻辑像素)在小于等于480px的时候的样式

#### and操作符

and操作符是用来连接“媒体查询”的设置的

```html
@media screen and (min-width:480px)
// 屏幕是手机/电脑并且屏幕大于等于480px的时候的样式
@media screen and (min-width:480px) and (max-width:767px)
// 屏幕大于等于480px且小于767px时候的样式
```

#### 常用节点

|              | 超小屏幕 手机(<768px) | 小屏幕 平板(>=768px) | 中等屏幕 桌面显示器(>=992px) | 大屏幕 大桌面显示器(>=1200px) |
| ------------ | --------------------- | -------------------- | ---------------------------- | ----------------------------- |
| 格栅系统行为 | 总是水平排列          | 开始是堆叠在一起的，当大于这些阀值时将变为水平排列   | 开始是堆叠在一起的，当大于这些阀值时将变为水平排列 | 开始是堆叠在一起的，当大于这些阀值时将变为水平排列 |
| 最大宽度 | None(自动) | 750px | 970px | 1170px |

## 移动端布局

### 常见移动端尺寸

- px：像素
- em：是相对长度单位。相对于当前对象内本文的字体尺寸（如果没有设置文本尺寸，那就是相对于浏览器默认的字体尺寸，也就是16px），这样计算的话。如果没有设置字体尺寸就是1em=16px。
- rem：rem和em一样也是相对长度单位，但是不一样的是rem始终都是相对于html根元素，不会受到对象内文本字体尺寸的影响，而且只需要改变根元素就能改变所有的字体大小。适合做响应式页面布局。
- vw和vh：相对于视口的高度和宽度，就是根据浏览器窗口的大小的单位，而不是父元素的（css百分比是相对于包含它的最近的父元素的高度和宽度）。
  1vh等于1/100的视口高度，1vw等于1/100的视口宽度。

### 动态计算根节点的font-size的js的方案

比如设置根页面的字体大小为100px，则1rem=100px，针对750px的效果图，用rem表示就是7.5rem，即根页面字体大小为100px对应7.5rem，但是不同的屏幕大小不同，所以要根据不同的屏幕设置不同的字体大小，屏幕尺寸可以用 window.innerWidth获取，设为w。750屏幕对应100px，那么w屏幕宽度对应字体大小为y，即750:100=w:y，则y=w*100/750=w/7.5；

```javascript
;(function () {
    function setFontSize() {
        var w = window.innerWidth;
        document.documentElement.style.fontSize = w / 7.5 + "px";
    }
    setFontSize();
    var t;
    window.addEventListener("resize", function () {
        clearTimeout(t);
        t = setTimeout(function () {
            setFontSize();
        }, 200);
    }, false);
}) ()
```

# HTML5

## HTML5新结构标签

### HTML5的优势

1. 移动端Android browser与  IOS Safari  都对HTML5有非常好的支持，移动端现在是大热，依靠Android 与 IOS、Windows开发成本巨大，WEBAPP页面必然越来越热；
2. HTML5的 CANVAS 元素能够很好的制作特效动画，取代 FLASH；
3. 视频的播放功能的提升；
4. 新增的语义标签让HTML页面内容更清晰，便于搜索引擎搜索。

### 新增的元素

1. 新增的结构元素
   section、article、aside、header、hgroup、footer、nav、figure、figcaption
2. 新增的其他元素
   video、audio、canvas、embed、mark、progress、meter、time、ruby、rt、   rp、wbr、command、details、datalist、datagrid、keygen、output、source    menu
3. 新增的input元素的类型
   email、url、number、range、DatePickers、color

### 新增的结构标签

1. <header>定义页眉
   header元素是一种具有引导和导航作用的结构元素，通常用来放置整个页面或页面内的一个内容区块的标题，但是也可以包含其他内容。

2. <footer>定义页脚
   footer元素定义文档或章节的末尾部分，通常包含一些章节的基本信息，如作者信息、相关链接及版权信息。

3. <nav>定义导航
   nav元素是一个可以用作页面导航的链接组，其中的导航元素链接到其他页面或当前页面的其他部分。并不是所有的链接组都要被放进nav元素，只需要将主要的、基本的链接组放进nav元素即可。

4. <article> 定义文章
   article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。他可以是一篇博客或者报刊中的文章，一篇论坛帖子、一段用户评论或独立的插件，或者其他任何独立的内容。
   article元素是可以嵌套使用的,语义化更好

5. <section> 定义文档中的区段
   section元素用于对网站或应用程序中页面上的内容进行分块。一个section元素通常由内容及其标题组成。但section元素并非一个普通的容器元素；当一个容器需要直接定义样式或通过脚本定义行为时，推荐使用div而非section元素。

   ```html
   <!--注意
   1、不要将section元素作为设置样式的页面容器
   2、如果article元素、aside元素、nav元素更符合使用条件，那不要使用section元素
   3、没有标题内容，不要使用section元素(每一个板块都是有主体的)-->
   <article>
   <section>
   	<h2>什么是safari</h2>
   	<p>苹果的浏览器</p>
   </section>
   <section>
   	<h2>什么是android browser</h2>
   	<p>Android系统下的手机浏览器</p>
   </section>
   </article>
   ```

6. <aside> 定义文章的侧边栏
   aside元素用来表示当前页面或文章的附属信息部分，它可以包含与当前页面或主要内容相关的引用、侧边栏、广告、导航条，以及其他类似的有区别于主要内容的部分。     
    aside往往用于侧边栏的使用，特别是2分栏、3分栏的侧边栏的使用

7. <hgroup>定义网页标题
    定义网页栏目或者模块之间的导航

8. <figure> 一组媒体对象以及文字

9. <figcaption> 定义 figure 的标题
   标签定义独立的流内容（图像、图表、照片等等）。图文混排

   ```html
   <figure>
     <p>黄浦江上的的卢浦大桥</p>
     <img src="shanghai_lupu_bridge.jpg" width="350" height="234" />
   </figure>
   <figure>
     <figcaption>黄浦江上的的卢浦大桥</figcaption>
     <img src="shanghai_lupu_bridge.jpg" width="350" eight="234" />
   </figure>
   ```

### 新增的属性

```html
contentEditable属性  ,值为true表示让标签内容可以编写
例： <p contentEditable=”true” >内容</p>
designMode属性(js操作document属性)
例： 在js中添加 document.designMode="on",整个页面都是可以编写的,可以用来
hidden属性
例 ： <p hidden>这个段落应该被隐藏。</p>
spellcheck属性(拼写检查：默认为true,可改为false)
例： <p contenteditable="true" spellcheck="true">这是可编辑的段落。请试着编辑文本。</p>
tabindex属性  :规定元素的 tab 键控制次序（当 tab 键用于导航时）
例： <p tabindex="2">电影</p>
```

## 网站缩略图

### base64编码

1. 减少不必要的http请求；
2. 图片小，又不适合做成图片精灵图；
3. 使用步骤：
   base64编码/解码的网站：http://tool.css-js.com/base64.html
   https://www.css-js.com/tools/base64.html     
   （1）Base64目前主要用于HTML5、移动开发等不考虑IE6的场景中。      
   （2）Base64 在CSS中的使用.demoImg{ background-image: url("data:image/jpg;base64,/9j/4QMZRXhpZgAASUkqAAgAAAAL...."); }
   Base64 在HTML中的使用<img width="40" height="30" src="data:image/jpg;base64,/9j/4QMZRXhpZgAASUkqAAgAAAAL...." />

### webp格式

​	WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。
	但WebP是一种有损压缩。相较编码JPEG文件，编码同样质量的WebP文件需要占用更多的计算资源。桌面版Chrome可打开WebP格式。适合大图片

​	1、下载软件： xnconvert   并安装
	2、把jpg图片放在tu文件夹
	3、打开软件，选择文件夹'tu',  切换到输出--->选择输出后文件夹，选择格式“webp”
	4、单击”转换“
	5、ok

## 表单新控件、新属性

1. 选项列表效果：输入字符后，会有下拉提示。

   ```html
   		<input type="text" list="mydata" placeholder="请输入商品名称">选项列表<br>
           <datalist id="mydata">
               <option label="10项" value="女鞋">
               <option label="13项" value="文具">
               <option label="45项" value="自行车">
               <option label="23项" value="平衡车">
               <option label="5项" value="扫地机">
           </datalist>
   ```

   ​	placeholder属性能够让你在文本框里显示提示信息，一旦你在文本框里输入了什么信息，提示信息就会隐藏。你以前可能无数次看到这种效果，但那些大部分是用JavaScript里实现的，而现在，HTML5提供了原生支持，而且效果更好！

2. 必填字段、正则验证、类型匹配
   效果：提交（而不是失去焦点）数据时，验证数据合法性，如何不符合要求，显示错误信息，并阻止提交

   ```html
   	<form action="">//如果不写action,,默认是提交到自身
           必填：<input type="text" required  autofocus/> <br>   <!-- 必填 -->
           正则：<input type="text" pattern="[0-9]{10}" /> <br>     <!-- 正则 -->
           email: <input type="email" /><br>     <!-- email格式 -->
           url: <input type="url" /> <br>    <!-- url格式,必须有http或者https开头 -->
           <input type="submit">
        </form>
   ```

   表单控件新增属性： required、pattern、autofocus

3. 数字字段、滑动组件、日期字段、时间字段、拾色器

   ```html
   数字字段： <input type="number" min="1" max="10" value="1" step="2"><br>
   滑动组件：<input type="range" min="1" max="10" value="1"><br>
   拾色器： <input type="color" value="#ed1c24" ><br>
   ```

4. 搜索、时间控件

   ```html
   搜索按钮：<input type="search" /><br>   <!-- 手机键盘会显示“搜索”键 -->
   日期字段：<input type="date" min="2010-12-16"  value="2016-12-20"/><br>
   时间字段：<input type="time" step="1800" /><br>  <!-- 可选：date | week | month | time | datetime -->
   ```

5. form 属性
   form 属性规定输入域所属的一个或多个表单。
   注释：form 属性适用于所有 <input> 标签的类型。
   form 属性必须引用所属表单的 id：

   ```html
   <form action="demo_form.asp" method="get" id="user_form">
   First name:      <input type="text" name="fname" />
                           <input type="submit" />
   </form>
   Last name:    <input type="text" name="lname" form="user_form" />   form属性和要提交的form表单的id属性值一致
   ```

6. formaction 属性
   同一个表单可以选择提交给不同的数据处理程序：

   ```html
   <form action="demo_form.asp" method="get" >
            First name:      <input type="text" name="fname" />
             Last name:     <input type="text" name="lname"  />
           <input type="submit"  value="注册" formaction="register.php"/>
          <input type="submit"  value="登录" formaction="login.php"/>
          <input type="submit"  value="post方法提交" formmethod="post" formaction="login.php"/>
    </form>
   ```

7. <time>标签
   标签定义公历的时间（24 小时制）或日期,便于搜索引擎搜索。

   ```html
   <p>我们在每天早上 <time>9:00</time> 开始营业。</p>
   <p>网页修改时间 ： <time > 2016-05-14 </time> </p>
   ```

8. <details>、<summary>标签
   在标准中提到的，但依然绝大部分浏览器都不支持的标签，目前只有chrome支持（最新版本）。

   ```html
   <details>   
           <summary>玩具品牌</summary>   
           <p> 澳贝 </p>
           <p> 奥迪双钻 </p>
    </details>
    <details>   
           <summary>牛奶品牌</summary>   
           <p>雅培 </p>
           <p>飞鹤 </p>
    </details>
   ```

9. <progress>
   定义进度条。

   ```html
   <progress value="22" max="100"></progress>
   ```

## 本地存储

### 客户端存储数据的方法

- cookie方法
- localStorage方法
- sessionStorage方法

### localStorage

1. 存储特点
   localStorage方法存储的数据没有时间限制。第二天、第二周甚至是第二年之后，数据依然可用。      
   不能跨浏览器读取数据,不能跨域
2. API（应用程序接口）
   保存数据：localStorage.setItem(key,value); :推荐使用这种方式	         
   		 localStorage.key = value;           
   		 localStorage[“key”]= value;
   读取数据：localStorage.getItem(key); :如果没有返回的null	         
    		localStorage.key, localStorage[“key”]:如果没有返回的是undefiend
   删除单个数据：localStorage.removeItem(key); 如果没有返回的是undefined
   删除所有数据：localStorage.clear(); 

### sessionStorage

1. 存储特点
   sessionStorage的方法针对一个session进行数据存储。当用户关闭浏览器窗口后，数据会被删除。存放在内存的
2. API：
   保存数据：sessionStorage.setItem(key,value); 
   	          sessionStorage.key = value;
   读取数据：sessionStorage.getItem(key);
    	           sessionStorage.key
   删除单个数据：sessionStorage.removeItem(key); 
   删除所有数据：sessionStorage.clear(); 

### sessionStorage， localStorage，cookie的区别

共同点：都是保存在浏览器端，且同源的。

区别：

1. 与服务器的数据交换方式不同。 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。
2. 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
4. 作用域不同，sessionStorage、localStorage不在不同的浏览器窗口中共享，即使是同一个页面；cookie也是在所有同源窗口中都是共享的。
   http://www.ruanyifeng.com/blog/2018/07/indexeddb.html

## 离线存储之Application Cache

### 离线存储之Application Cache

1. 什么是应用缓存（Application Cache）
   HTML5引入了应用程序缓存（又叫离线缓存），这意味着web应用可进行缓存，并可在没有网络连接时进行访问。      
2. 应用缓存的优势
    1）离线浏览-用户可以在离线状态下浏览网站内容
    2）速度-因为数据被存储在本地，所以速度会更快  
    3）减少服务器负载-浏览器只会下载在服务器上发生改变的资源

### 访问流程

 第一次正确配置app cache(manifest)后，当我们再次访问该应用时，浏览器会首先检查manifest文件是否有变动，如果有变动就会把相应的变动更新下来，同时改变浏览器里面的app cache，如果没有变动，就会直接把app cache的资源返回，基本流程是这样的。

### 如何应用

1. 安装PHP测试环境

2. 在PHPStudy中>其他选项菜单>打开配置文件> 在httpd.conf 中查找： AddType ,  在找到的行后换行添加 ： AddType text/cache-manifest .manifest(注意里面的空格)  
   html开始标签中添加:<html lang="en" manifest="manifest.manifest">

3. 然后在相同目录下新建一个manifest.manifest文件，注意关于路径要和html页面配置时一致即可。

   ```manifest
   CACHE MANIFEST              第一行是固定格式
   #version 1.3                          #表示是注释
   CACHE:  		cache下面的是缓存清单                              
     test.css
   NETWORK:
       *                                      *表示除了缓存清单里面的文件,其他的都是需要访问网络的
   ```

   关于manifest.manifest文件，基本格式为三段： CACHE， NETWORK，与 FALLBACK，其中NETWORK和FALLBACK为可选项，而第一行CACHE MANIFEST为固定格式，必须写在前面。

   CACHE:（必须）
   	标识出哪些文件需要缓存，可以是相对路径也可以是绝对路径。例如：aa.css，http://www.baidu.com/aa.js. 

   NETWORK:（可选）
   	这一部分是要绕过缓存直接读取的文件，可以使用通配符＊，也就是说除了上面的cache文件，剩下的文件每次都要重新拉取。例如＊，login.php。

   FALLBACK:（可选）
   	指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。例如/  /offline.html。

### 更新缓存的方式

1. 更新manifest文件
   浏览器发现manifest文件本身发生变化，便会根据新的manifest文件去获取新的资源进行缓存。当manifest文件列表并没有变化的时候，我们通常通过修改manifest注释的方式来改变文件，从而实现更新。
   appcache更新了缓存重新从网络上拉取需要cache的文件，但是，我们如果想要看到改变，必须再次刷新页面。

2. 通过javascript操作:添加此处的代码用户就不需要手动刷新页面了
   浏览器提供了applicationCache供js访问，通过对于applicationCache对象的操作也能达到更新缓存的目的。

   ```javascript
   window.addEventListener('load', function (e) {
               window.applicationCache.addEventListener('updateready', function (e) {
                   if (window.applicationCache.status == window.applicationCache.UPDATEREADY) {
                       // 调用applicationCache.swapCache()即可将原缓存换成新缓存。
                       window.applicationCache.swapCache();
                       window.location.reload();
                   }
               }, false);
           }, false);
   ```

3. 清除浏览器缓存

### 注意事项

-  站点离线存储的容量限制是5M 
-  如果manifest文件，或者内部列举的某一个文件不能正常下载，整个更新过程将视为失败，浏览器继续全部使用老的缓存  
- 引用manifest的html必须与manifest文件同源，在同一个域下 
-  FALLBACK中的资源必须和manifest文件同源  
- 当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。 
-  当manifest文件发生改变时，资源请求本身也会触发更新 
- app cache 不能跨浏览器使用

### 检查设备是否在线

```javascript
if (navigator.onLine){
	alert('online');
}else{
	alert('offline');
}
```

# css面试题

## 隐藏属性display:block;和visibility:hidden;

​	display:block;隐藏不占位置；

​	visibility:hidden;隐藏占位置；

## 行内元素和行内块元素在浏览器中会出现缝隙

​	产生缝隙的原因：

​		浏览器会将空白字符（tab键，空格，换行）解析成一个空格导致的

​	解决方法：

​		给父元素设置font-size：0；给自身重新设置font-size大小；

## css三大特征

​	层叠性：样式冲突

​	继承：继承祖先元素的样式

​			可以继承的属性：文字和文本属性可以继承（color，font-size，font-familily，，，line-height） 

​	优先级：

​		权重：继承<*<标签<class<id<行内

# JavaScript

JavaScript是脚本语言；JavaScript 是一种轻量级的编程语言；JavaScript 是可插入 HTML 页面的编程代码；

JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。

## JavaScript入门

### javascript的组成部分

1. 语法 ECMAscript
2. DOM    document object model  文档对象模型
   - 操作html+css
3. BOM    borwser object mode  浏览器对象模型
   - 根据浏览器的变化实现特效

### js的运行

​	js试运行在浏览器上的，跟操作系统无关，与浏览器内核有关

### 浏览器内核

​            渲染引擎（html+css），js引擎（js）

### 常见的浏览器内核

​            webkit：苹果/google
            blink：google
            gecko：火狐
            trident：IE

## 关键字与保留字

**关键字：**

​	break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with。

**保留字：**

​	abstract、boolean、byte、char、class、const、debugger、double、enum、export、extends、final、float、goto、implements、import、int、interface、long、native、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile

## JS弹出框

文本输入框：prompt（）；

警告框：alert（）；

确认框：confirm（）；

## 变量的声明

在JS中，只通过var关键字声明变量，

- 变量必须以字母开头
- 变量也能以 $ 和 _ 符号开头（不过不推荐这么做）
- 变量名称对大小写敏感（y 和 Y 是不同的变量）
- 如果只声明变量而不给变量赋值，则该变量默认为undefined

## JavaScript数据类型

JavaScript有七大数据类型：

​	分别为：字符串(String)，数字(Number)，布尔(Boolean)，数组(Array)，对象(Object)，undefined，null。

**常用数据类型**

​	Number,String,Boolean,Undefined//变量声明，但未赋值 

**JavaScript中的数据类型分为**

​	**--简单数据类型**：Number,String,Boolean	Undefined,Null

​	**--复杂数据类型**：Object,Array,Date

查看当前变量的数据类型

——typeof name

——typeof(name)

**String类型**

​	字符串是由一个一个字符组成，获取字符串长度使用length

​	字符串是不可变的，当这个字符串赋值以后，这个字符串的地址就不会发生变化，如果要重新赋值，则会重新开辟内存空间。

​	当一个字符串类型与一个数字类型相加，则加号变为连接符，并且数值类型隐式转换为字符串类型，两者在进行拼接。

​	当一个字符类型与数字类型相减，若字符类型可以转化为数字类型，则进行转化，然后两则进行减法运算，若不能结果为NaN。

**Boolean类型**

空字符串，0，NaN，null，undefined---都转化为false  //无具体值，可以判断变量是否有值

## 类型转换

**转换成字符**

1. toString()方法；可以携带一个参数，输出对应进制的值

   ​	如

   ```javascript
   	var age = 18;
   	var ageString = age.toString();
   	console.log(ageString); //结果“18”
   	
   	var num = 10;
   	console.log(num.toString(2));   //1010  将10用基数为2的进制表示出来
   ```

2. String()函数，有些值没有toString()，这个时候可以使用String()。比如undefined和null。

   ​	如：

   ```javascript
   var age = 18;
   console.log(String(age)); //结果“18“
   ```

3. 字符串拼接，通过”+“。

**转换成数值类型**

​	三个把值转换成数值类型的函数：Number()、parseInt()、parseFloat()

——Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN。

——parseInt()把字符串转换为整数，如果第一个字符是数字会解析直到非数字结束，如果第一个字符不是数字或者符号就返回NaN，空字符串返回NaN，Number("")返回0。parseInt()可以传递两个参数a,b，即把a转换为b进制的整数 。

```
console.log(parseInt(num, 8)); //8  将10转换为8进制的整数
```

​	parseInt()在进行数据类型转换时，当被转换的为boolean，null，undefined时，转换结果为NaN,当被转换类型为字符串时，会从左到右查找，遇到第一个非数字结束，不保留小数点，返回结果

——parseFloat()把字符串转换成浮点数，和parseInt非常相似，但不支持第二个参数。

​	parseFloat()与parseInt()类似，唯一一点区别是parseInt()不保留小数点，二parseFloat()保留一位小数点 

```javascript
	var a = "123abc";
        a = Number(a);
        console.log(a); //NaN
        a = "123";
        a = Number(a);
        console.log(a);  //123
        a = "123.123";
        a = Number(a);
        console.log(a);  //123.123
	var b = "123abc";
        var c = parseInt(b); 
        var d = parseFloat(b);
        console.log(c);  //123
        console.log(d);  //123
        var b = "abc123";
        var c = parseInt(b); 
        var d = parseFloat(b);
        console.log(c);  //NaN
        console.log(d);  //NaN
        var b = "123.123abc";
        var c = parseInt(b); 
        var d = parseFloat(b);
        console.log(c);  //123
        console.log(d);  //123.123
     var num = "10";
        num = parseInt(num,"2");
        console.log(num); //2
        
    	console.log(Number(true));    //1
     	console.log(Number(false));    //0
        console.log(Number(null));    //0
        console.log(Number(undefined));    //NaN
```

**转换成布尔类型**

——Boolean()函数

——流程控制语句会把后面的值隐式转换成布尔类型

## 数值检测

- NaN非数值（Not a Number）

——console.log("abc"/18);//结果是NaN

——NaN与任何值都不相等，包括NaN本身

- isNaN()：任何不能被转换为数值的值都会导致这个函数返回true

——isNaN(NaN); //true

——isNaN("blue"); //true

——isNaN(123); //false

## 全局变量与局部变量

​		全局变量可以被任意调用，局部变量只可被包含它的函数调用；
                浏览器在解析javascript代码时，会将变量声明提到最前面，变量赋值留在原地；
                在函数外 使用var定义变量和直接给变量赋值都代表全局变量；
                在函数内部 ，使用var定义变量的为局部变量，直接给变量赋值的也为全局变量。

## 一元运算符

​	i++,++i,i--,--i;

以++为例，

```javascript
		var a = 1; var num1 = ++a + ++a;
        	console.log("num1="+num1); //5
         a = 1; var num2 = ++a + a++;
       	    console.log("num2="+num2); //4
         a = 1; var num3 = a++ + ++a;
        	console.log("num3="+num3); //4
       	 a = 1;  var num4 = a++ + a++;	
        	console.log("num4="+num4); //3
```

## 复合运算符

i = i + 2;等价于i += 2;

## 逻辑运算符

与&&，或||，非！

&& 逻辑与  有一个为false，结果就为false
          当&&两个操作数都不是布尔类型，如果两个数转换为布尔类型都为true，返回第二个操作数；如果两个数转换为布尔类型都为false，返回第一个操作数；若第一个为true，第二个为false，返回第二个操作数；若第一个为false，第二个为true，返回第一个操作数

|| 逻辑或  有一个为true，结果就为true
          当||两个操作数都不是布尔类型，如果两个数转换为布尔类型都为true，返回第一个操作数；如果两个数转换为布尔类型都为false，返回第二个操作数；若第一个为true，第二个为false，返回第一个操作数；若第一个为false，第二个为true，返回第二个操作数

！ 逻辑非， 逻辑取反​

```javascript
		// &&非布尔类型
        	var str1 = "abc"&&"bcd";
        	console.log("sty1="+str1); //bcd
        	var str2 = "abc"&&undefined;
        	console.log("sty2="+str2); //undefined
        	var str3 = undefined&&"bcd";
        	console.log("sty3="+str3); //undefined
        	var str4 = null&&undefined;
        	console.log("str4="+str4); //null
        // ||非布尔类型
        	var str5 = "abc"||"bcd";
        	console.log("sty1="+str5); //abc
        	var str6 = "abc"||undefined;
        	console.log("sty2="+str6); //abc
        	var str7 = undefined||"bcd";
        	console.log("sty3="+str7); //bcd
        	var str8 = null||undefined;
        	console.log("str4="+str8); //undefined
```

逻辑运算符的短路

​	&&   当第一个条件为假时，结果就为假，后面的条件不再执行
        ||   当第一个条件为真时，结果就为真，后面的条件不再执行

## 条件运算符

- *if 语句* - 只有当指定条件为 true 时，使用该语句来执行代码
- *if...else 语句* - 当条件为 true 时执行代码，当条件为 false 时执行其他代码
- *if...else if....else 语句* - 使用该语句来选择多个代码块之一来执行
- *switch 语句* - 使用该语句来选择多个代码块之一来执行

### if...else

```javascript
if (条件)
  {
  	当条件为 true 时执行的代码
  }
else
  {
  	当条件不为 true 时执行的代码
  }
```

### switch

​	请使用 switch 语句来选择要执行的多个代码块之一。 

```javascript
switch(n)
{
case 1:
  执行代码块 1
  break;
case 2:
  执行代码块 2
  break;
default:
  n 与 case 1 和 case 2 不匹配时执行的代码
}
```

​	default关键词

​		使用 default 关键词来规定匹配不存在时做的事情： 

​	实例：如果今天不是周六或周日，则会输出默认的消息： 

```javascript
var day=new Date().getDay();
switch (day)
{
case 6:
  x="Today it's Saturday";
  break;
case 0:
  x="Today it's Sunday";
  break;
default:
  x="Looking forward to the Weekend";
}
```

### 三目运算符

（条件）？（条件成立返回该语句）：（条件不成立返回该语句）

```javascript
var num = 3==="3"?"相等":"不等";
        console.log(num); //不等
//求x,y,z的最大、最小值
     var x=20,y=18,z=50;
        var maxNum=x>y?(x>z?x:z):(y>z?y:z);
        var minNum=x<y?(x<z?x:z):(y<z?y:z);
```

## 循环运算符

一遍又一遍地运行相同的代码，并且每次的值都不同，则使用循环。 

- *for* - 循环代码块一定的次数
- *for/in* - 循环遍历对象的属性
- *while* - 当指定的条件为 true 时循环指定的代码块
- *do/while* - 同样当指定的条件为 true 时循环指定的代码块

### for

```javascript
for (语句 1; 语句 2; 语句 3)
  {
  被执行的代码块
  }
```

​	语句 1* 在循环（代码块）开始前执行

​	语句 2* 定义运行循环（代码块）的条件

​	*语句 3* *在循环（代码块）已被执行之后执行

```javascript
		//打印1到100的和`
        var sum = 0;
        for (var i = 1; i <= 100; i++) {
            sum += i;
        }
        console.log("1到100的和为："+sum); //5050
```

### for...in

```javascript
	语法：
		for (property in expression) statement
	例：
		for (var propName in window) {
            document.write(propName);
		}
	例：
		var sum = 0;
        for(var i in arr) {
            sum += arr[i];
        }
        console.log("数组之和为："+sum);
```

​	ECMAScript对象的属性没有顺序。因此，通过for-in循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。

​	如果迭代的对象的变量值为null或undefined，for-in语句会抛出错误。为了保证最大限度的兼容性，在使用for-in循环之前，先检测确认该对象的值不是null或undefined。

### while

```javascript
while (条件)
  {
  需要执行的代码
  }
```

```javascript
//计算1到100 的和
        var sum = 0;
        var i = 1;
        while (i <= 100) { //先判断 再执行
            sum += i;
            i++;
        }
        console.log(sum); //5050
```

### do...while

```javascript
do
  {
  需要执行的代码
  }
while (条件);
```

```javascript
	//计算1到100 的和
	var sum = 0;
        var i = 1;
        do { //先执行 后判断
            sum += i;
            i++;
        } while(i <= 100);  //当i=101时跳出循环
        console.log(sum); //5050
```

### break和continue

​	break 语句用于跳出循环。

​	continue 用于跳过循环中的一个迭代。跳出本次循环，继续下次循环。

## JS运算符

​	**JavaScript算术运算符**

给定 *y=5*，下面的表格解释了这些算术运算符： 

| 运算符 | 描述              | 例子  | 结果  |
| ------ | ----------------- | ----- | ----- |
| +      | 加                | x=y+2 | x=7   |
| -      | 减                | x=y-2 | x=3   |
| *      | 乘                | x=y*2 | x=10  |
| /      | 除                | x=y/2 | x=2.5 |
| %      | 求余数 (保留整数) | x=y%2 | x=1   |
| ++     | 累加              | x=++y | x=6   |
| --     | 递减              | x=--y | x=4   |

​	**JavaScript赋值运算符**

给定 *x=10* 和 *y=5*，下面的表格解释了赋值运算符： 

| 运算符 | 例子 | 等价于 | 结果 |
| ------ | ---- | ------ | ---- |
| =      | x=y  |        | x=5  |
| +=     | x+=y | x=x+y  | x=15 |
| -=     | x-=y | x=x-y  | x=5  |
| *=     | x*=y | x=x*y  | x=50 |
| /=     | x/=y | x=x/y  | x=2  |
| %=     | x%=y | x=x%y  | x=0  |

​	**JavaScript比较运算符**

给定 x=5，下面的表格解释了比较运算符： 

| 运算符 | 描述             | 例子                            |
| ------ | ---------------- | ------------------------------- |
| ==     | 等于             | x==8 为 false                   |
| ===    | 全等（值和类型） | x===5 为 true；x==="5" 为 false |
| !=     | 不等于           | x!=8 为 true                    |
| >      | 大于             | x>8 为 false                    |
| <      | 小于             | x<8 为 true                     |
| >=     | 大于或等于       | x>=8 为 false                   |
| <=     | 小于或等于       | x<=8 为 true                    |

​	**JS逻辑运算符**

给定  x=6 以及 y=3，下表解释了逻辑运算符：

| 运算符 | 描述 | 例子                      |
| ------ | ---- | ------------------------- |
| &&     | and  | (x < 10 && y > 1) 为 true |
| \|\|   | or   | (x==5 \|\| y==5) 为 false |
| !      | not  | !(x==y) 为 true           |

​	**运算符的优先级**

优先级从高到底

——（）优先级最高

——一元运算符++  --  ！

——算术运算符 先* / % 后+ -

——关系运算符 >  >=  <  <=

——相等运算符==  !=  ===  !==

——逻辑运算符 先&& 后||

## 数组（Array）

​	数组索引从零开始，获取数组的长度  array.length。

**定义数组的方法**

1. ​	var array = new Array();
                 array[0] = "值1";
                 array[1] = "值2";
2. ​        var array = Array("值1","值2","...");
3. ​        var array = ["值1","值2","..."];  //一般使用该方法

**例题：**

```javascript
//求一组数中所有数的和  和平均数
        var arr = [25,14,36,45,12,32,78,86,45];
        var num = 0;
        var avg;
        for (var i = 0; i < arr.length; i++) { //循环遍历每一个数
            num += arr[i];
        }
        avg = num / arr.length;
        console.log("和为："+num);
        console.log("平均数为："+avg);
 //求一组数中的最大值和最小值，以及所在位置
        var arr = [250,14,36,45,12,32,78,86,45];
        // 循环遍历每一个数
        // 假设第一个数为最大值或最小值  即max = arr[0];  min = arr[0];
        // 将数组中的最大值的最小值存储起来
        var max = arr[0];min = arr[0];
        var maxIndex = 0,minIndex = 0;
        for(var i = 1; i < arr.length; i++) {
            if(max >= arr[i]) {
                if(min <= arr[i]) {
                    continue;
                } else {
                    min = arr[i];
                    minIndex = i;
                }
            } else {
                max = arr[i];
                maxIndex = i;
            }
        }
        console.log("数组中的最小值为：arr["+minIndex+"]="+min);
        console.log("数组中的最大值为：arr["+maxIndex+"]="+max);
//将数组中的非零数字提出放到一个新的数组中，将零删除
        var arr1 = [0,250,14,0,36,45,0,12,32,78,86,45];
        var arr2 = [];
        for(var i = 0; i < arr1.length; i++) {
            if(arr1[i] !== 0) {
                arr2[arr2.length] = arr1[i];
            }
        }
        console.log(arr2);
 //冒泡排序
         var arr = [1,2,3,4,5,6,7];
         var s = 0;
         var s1 = 0;
         for (var i = 0; i < arr.length - 1; i++) {
            //循环趟数
            var isSort = true;  //如果没有排好顺序，则isSort为true
            for (var j = 0; j < arr.length - 1 - i; j++) {
                //从小到大排序，大的放最后面
                if(arr[j] >= arr[j+1]) {
                    isSort = false;  //没有排好顺序
                    //交换位置
                    var tmp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = tmp;
                }
                s++;
            }
            s1++;
            if(isSort) {  //已经排好序，此时跳出循环
                break;
            }
        }
        console.log("内循环次数为："+s);
        console.log("外循环次数为："+s1);
        console.log(arr);
```

### 数组的方法

1.concat():连接两个或多个数组

2.indexOf(arg):

​            查找数组中的arg元素，如果没有，则返回-1，如果有，则返回该元素的最小下标

​     lastIndexOf(arg):

​            查找数组中的arg元素，如果没有，则返回-1，如果有，则返回该元素的最大下标

3.join();将数组中的内容拼接成字符串返回，默认是以分号分割的，可以指定分割符号

4.pop();删除数组的最后一个元素，并将删除的元素返回

5.push();向数组的末尾添加一个或更多元素，并返回添加后的长度

6.reverse();反转数组

7.shift();删除并返回数组的第一个元素

8.slice();选取数组的一部分，并返回一个新数组，如果有两个参数a, b，则返回下标a到b的内容[a, b)，包含下标a，不包含下标b，如果只有一个参数，则返回下标a到数组结束的内容

9.splice();向数组中添加或删除元素,如果只含有两个参数，则第一个是表示从第几个下标开始删除，第二个是表示需要删除几个值，如果后面还有内容，则表示添加到数组的内容，如果只添加不删除，则令第二个值为0

10.sort();数组排序，默认是以ask码排序

```javascript
		var arr1 = [1, 2, 3, 4];
        var arr2 = [5, 6, 7, 8];
        var arr3 = [1, 2, 3, 4];
        // ===========concat
            var arr = arr1.concat(arr2, arr3);
            console.log(arr);
        // ============indexOf
            var index = arr.indexOf(1);
            console.log(index);
        // ============lastIndexOf
            var index1 = arr.lastIndexOf(1);
            console.log(index1);
        // ============join
            var str = arr.join("--");
            console.log(str);
        // =============pop
            var str1 = arr.pop();
            console.log(str1);
        // ============push()
            console.log(arr.length);
            var num = arr.push(2, 45, 199);
            console.log(num);
        // ===========reverse()
            console.log(arr);
            arr.reverse();
            console.log(arr);
        // ===========shift()
            var num1 = arr.shift();
            console.log(num1);
        // ============slice()
            console.log(arr);
            var str2 = arr.slice(6, 8);
            console.log(str2);
        // ============splice()
            console.log(arr);
            arr.splice(1, 4);
            console.log(arr);
            arr.splice(1, 0, 34, 43);
            console.log(arr);
        // ============sort()
            var arr4 = [34, 12, 32, 54, 9, 10, 11, 21, 45, 6];
            var arr5 = arr4.sort();
            console.log(arr5);
            var arr6 = arr4.sort(function(a, b) {
                // return a - b;   //指定按数字从小到大排序
                return b - a;   //指定按数字从大到小排序
            });
            console.log(arr6);
```

```javascript
	// 数组中元素为对象，通过对象的age对数组进行排序
        var arr = [
            {
                name: "xiaoming",
                age: 28,
                study: function() {
                    console.log("学习JavaScript");
                }
            }, 
            {
                name: "zhangsan",
                age: 20,
                study: function() {
                    console.log("学习Html");
                }
            }, 
            {
                name: "lishi",
                age: 156,
                study: function() {
                    console.log("学习css");
                }
            }
        ]
        var arr1 = arr.sort(function (a, b) {
            return a.age - b.age;
        });
        console.log(arr1);

```

## 字符串（String）

### 字符串的属性

length：字符串的长度

### 字符串的方法

1. charAt();返回字符串指定索引的字符；

2. concat();连接两个或多个字符串；

3. indexOf();返回字符串中检索指定字符第一次出现的位置；

4. lastIndexOf();返回字符串中检索指定字符最后一次出现的位置；

5. subString();提取字符串中两个指定索引之间的字符，包含第一个索引，不包含第二个索引。若只有一个，则从该索引到字符串最后；

6. slice();和subString相同，区别是slice可以取负值，当取负值时是从字符串后面开始查找；

7. substr(a, length);表示从下标a开始，往后查找length个字符，若只有a，则从a到最后,这里的a也可以为负值；

8. split();将字符串转换为字符串数组，方法中可以传值，代表拆分符号

   ```javascript
   var arr = [10, 20, 30, 40, 50, 60, 70];
   var str1 = arr.join("+");
   console.log(str1);		//10+20+30+40+50+60+70
   console.log(str1.split());		//Array [ "10+20+30+40+50+60+70" ]
   console.log(str1.split("+"));	//Array(7) [ "10", "20", "30", "40", "50", "60", "70" ]
   ```

9. toLowerCase();将字符串转换为小写；

10. toUpperCase();将字符串转换为大写；

11. trim();消除字符串首尾空白字符。

12. charCodeAt();返回指定索引位置字符的ASCII码；

13. fromCharCode();将ASCII码转换为字符串；

**判断字符串中出现次数最多的字符**

```javascript
<script>
        // 判断字符出现次数
        function charCount(str) {
            var obj = {};   //创建一个obj对象
            for (var i = 0; i < str.length; i++) {
            // 将字符串中的字符放入到obj对象的属性中
                if (obj[str[i]]) {  //如果对象中有该属性，则属性值加1,属性值即为字符出现的次数
                    obj[str[i]]++;
                } else {    //如果对象中没有该属性，则添加属性，并令属性值为1
                    obj[str[i]] = 1;
                }
            }
            var max = 0;    //定义一个最大值。即字符出现的次数的最大值
            var arr = [];   //定义一个数组存放出现次数最大的字符
            for (var j in obj) {    //遍历对象属性
                if (obj[j] > max) {     //如果属性值大于max，修改最大值，清空数组中存放的字符
                    max = obj[j];
                    arr = [];
                    arr.push(j);
                } else if (obj[j] == max) {  //解决字符串中有并列出现次数最大字符的情况
                    arr.push(j);
                }
            }
            return {	//将返回的字符和最大值通过对象返回
                character: arr,
                count: max
            }
        }
        var str = "asdfadsfasdfaa";
        var result = charCount(str);
        console.log("出现次数最多的字符是：" + result.character + "\n出现次数是：" + result.count);
    </script>
```

**查看指定字符在字符串中出现的次数**

```javascript
	// 第一种方法：使用字符串的split()方法查找字符串中指定字符出现的次数
        function checkNumber(str, subStr) {
            var arr = str.split(subStr);
            var count = arr.length - 1;
            count = count == -1 ? 0 : count;
            return count;
        }
        var str = "dsafsdafsafasa";
        console.log(checkNumber(str, "a"));
```

```javascript
	// 第二种方法：采用for循环，判断a在字符串中出现的次数
        var str = "asfdafadsaaaa";
        function wordCount(str, s) {
            var count = 0;
            for (var i = 0; i < str.length; i++) {
                if (str.charAt(i) == s) {
                    count++;
                }
            }
            return count;
        }
        console.log(wordCount(str, "a"));
```

**去重**

```

```

## Math

### math函数的属性

Math.PI:返回圆周率。

### math函数的方法

1. 绝对值:

   Math.abs();

2. 对数进行上舍入:

   Math.ceil();

3. 对数进行下舍入:

   Math.floor();

4. Math.pow(x, y);  x的y次幂，y可以是分数

5. 求最大最小值：Math.max();和Math.min();
   max和min方法中可以有多个值。

6. 随机数：

		Math.random();	随生成一个0到1之间的随机数，包含0，不包含1 

```javascript
		// 打印20到60之间的随机数
        var random = parseInt(Math.random() * (40+1) + 20);
        console.log(random);
        for (var i = 0; i < 100; i++) {
            random = parseInt(Math.random() * (40+1) + 20);
            console.log(random);
        }
```

```javascript
		//写一个函数，用来打印m到n之间的一个随机数[m, n]
		function getRandom(m, n) {
            return parseInt(Math.random()*(n - m + 1) + n);
		}
```

## Date(日期)

### 创建日期对象

var day = new Date();

### 日期对象常用方法

- a.获取

getFullYear()；从 Date 对象以四位数字返回年份。
getMonth()；从 Date 对象返回月份 (0 ~ 11)，0代表1月。
getDate()；从 Date 对象返回一个月中的某一天 (1 ~ 31)。
getHours()；返回 Date 对象的小时 (0 ~ 23)。时间方法名中都有s
getMinutes()；返回 Date 对象的分钟 (0 ~ 59)。
getSeconds()；返回 Date 对象的秒数 (0 ~ 59)。
getTime()；返回 1970 年 1 月 1 日至今的毫秒数。
getDay()；从 Date 对象返回一周中的某一天 (0 ~ 6)，0代表星期日。
getMilliseconds();返回 Date 对象的毫秒(0 ~ 999)。

- b.对应set方法为修改

- c.

toString();把 Date 对象转换为字符串。
toTimeString();把 Date 对象的时间部分转换为字符串。
toDateString();把 Date 对象的日期部分转换为字符串。

### 计算两个时间点间隔时间，返回天，时，分，秒

两种方法

```javascript
/**
 * 如果结束时间减去开始时间为负，则返回-1
 * 反之返回两者间隔的时分秒
 * @param {开始时间} beginTime 
 * @param {结束时间} endTime 
 */
function timeDifference(beginTime, endTime) {
    var time = endTime.getTime() - beginTime.getTime();
    if (time <= 0) {
        return -1;
    }
    var mSeconds = time % 1000;
    time = (time - mSeconds) / 1000;
    var seconds = time % 60;
    time = (time - seconds) / 60;
    var minutes = time % 60;
    time = (time - minutes) / 60;
    var hours = time % 60;
    time = (time - hours) / 24;
    return {	//将结果存放在对象中
        day: time,
        hours: hours,
        minutes: minutes,
        seconds: seconds
    }
}
```

```javascript
/**
 * 24h = 86400000ms
 * 1h = 3600000ms
 * 1min = 60000ms
 * 1s = 1000ms
 * @param {*} beginTime 
 * @param {*} endTime 
 */
function timeDiffer(beginTime, endTime) {
    var time = endTime - beginTime;
    if (time <= 0) {
        return -1;
    }
    var day = parseInt(time / 86400000);
    time = time % 86400000;
    var hours = parseInt(time / 3600000);
    time = time % 3600000;
    var minutes = parseInt(time / 60000);
    time = time % 60000;
    var seconds = parseInt(time / 1000);
    return {
        day: day,
        hours: hours,
        minutes: minutes,
        seconds: seconds
    }
}
```

## BOM计数器

### 常用方法

计时器用来设定指定时间之后单次或者重复来执行代码

- setTimeout() 指定的毫秒数之后执行指定的代码。
- setInterval() 间隔指定的毫秒数不停地执行指定的代码。
- clearTimeout() 用于停止执行setTimeout()方法的函数代码。
- clearInterval() 用于停止 setInterval() 方法执行的函数代码

setTimeout("move(index++)", 2000) ；当需要向定时器中的函数传参时，需要加引号。

```javascript
    // 通过setTimeOut实现setInterval效果，函数自调用
	var t = null;
    t = setTimeout("move(index++)", 2000);
    function move() {
        t = setTimeout("move(index++)", 2000);
    }
```

### 定时器

setInterval(function() {}, 1000);定时器，表示每个一秒执行一次里面的函数。1000表示1000毫秒，即一秒。

```javascript
		var i = 0;
        setInterval(function() {
            console.log(i);
            i++;
        }, 1000);   //1000表示1000毫秒，即一秒
        // 每个1秒函数运行一次，打印一次i
```

```javascript
	// 清除定时器，需要给定时器设置一个变量
	var i = 0;
	var t =  setInterval(function() {
        console.log(i);
        i++;
        if (i > 10) {
			clearInterval(t);
		}
    }, 1000);
```

## 函数

​	函数的作用：可以封装任意多的语句，而且可以在任何地方、任何时候调用。

### 函数的定义

​	（1）function 函数名(){ }；

​	（2）var 函数名 = function() {};

​	区别：第一种可以在任何地方调用，第二种只能在函数定义之后调用。

### 函数的参数

​	形参和和实参

​	形参是函数定义的变量，实参是函数调用时传递的参数。

​	如果实参比形参多，则多于的实参忽略；如果形参比实参多，则多余的形参为undefined。

​	伪数组：arguments

​		arguments.length是实参的长度，可以用数组的方式去遍历实参。

​	**基本数据类型和引用数据类型在内存中的存储方式：**基本数据类型的数据直接在栈中存储；引用数据类型数据在堆中存储，在栈中存放的是堆中对应的地址。

```javascript
	    var num1 = 20;
        var num2 = num1;
        num2 = 23;
        console.log(num1);	//20
        // 令num2 = num1，再改变num2值，不会改变num1的值
        var arr1 = [10, 20, 30];    //arr1存储的是数组在堆中的地址
        var arr2 = arr1;    //这里是将数组的地址复制给arr2
        arr2[0] = 100;  //改变了数组在堆中的值
        console.log(arr1);	//[100, 20, 30]
        
        function change(n) {
            n += 3;
        }
        var n1 = 10;
        change(n1);
        console.log(n1);    //10

        function changeArr(arr) {
            arr[0] += 3;
        }
        var arr3 = [20, 50, 40];
        changeArr(arr3);
        console.log(arr3[0]);  //23
```

![1539830636632](C:\Users\ADMINI~1\AppData\Local\Temp\1539830636632.png)



### 函数的返回值

​	函数可以有返回值,也可以没有返回值。如果函数有返回值,return语句,return是让函数结束。

​	哪种情况会出现undefined? 

​		函数 没有返回值,返回的是undefiend 

​		声明了变量,但是变量没有赋值,该变量默认的是undefiend

### 函数的递归

​	自己调用自己，必须有结束条件。

```javascript
 		// feibunaqi数列的递归
        function fun1(n) {
            if (n === 1 || n === 2) {
                return 1;
            } else {
                return fun1(n - 1) + fun1(n - 2);
            }
        }
        console.log(fun1(5));

        // 阶乘的递归
        function fun2(n) {
            if (n === 1) {
                return 1;
            } else {
                return n * fun2(n - 1);
            }
        }
        console.log(fun2(5));
```

### 函数的返回值还是函数

```javascript
		// sum(2, 3);   结果为5
        // sum(2)(3);   结果为5
        function sum(a, b) {
            if (arguments.length === 2) {
                return a + b;
            } else if (arguments.length === 1) {
                function sums(c) {
                    return a + c;
                }
                return sums; // 返回值是一个函数
            }
        }
        console.log(sum(2, 3));
        console.log(sum(2)(3)); //调用返回值函数

```

## 对象

​	1.对象拥有属性和方法；

​	2.除了字符串、数字、true、false、null和undefined之外，Javascript中的值都是对象。只有对象才具有方法和属性；

​	3.对象可以看做是属性的无需集合，每个属性都是一个键值对（属性名称：属性值）；

​	4.属性的值可以是任意数据类型（数字、字符串、数组、日期对象、算术对象、函数、对象等）；

​	5.Javascript对象是一种复合值：它是属性或已知命名的集合。通过“.”符号来引用属性值。当属性是一个函数的时候，我们称其为方法。通过o.m()来调用的对象o中的方法。

### 对象的定义方法

​	1.var obj = new Object();

​	2.var obj = {};	//字面量方式

```javascript
	1.使用object方式定义对象
		var stu = new Object();
        stu.name = "张三";
        stu.age = 18;
        stu.sno = "123456789";
        stu.eat = function() {
            console.log("吃饭");
        }
    2.使用字面量方式定义对象
        var student = {
            name: "xiaoming",
            age: 28,
            hobby: {
                ball: "乒乓球, 羽毛球, 篮球",
                sports: "run, swimming, andSoOn",
                others: "music, mov"
            },
            sex: "男"
        }
```

​	查看对象的属性值，可以使用  对象.属性  来查看，或者  对象["属性"]。如：

```javascript
		console.log(stu.name);  //张三
		console.log(stu["name"]);  //张三
```

### 对象的遍历

使用循环语句for...in...进行遍历，如：

```javascript
	    for (var i in stu) { //此处i表示的是对象的属性，可以使用stu[i]，想看对象的属性值
            var result = stu[i];
            console.log(i+":"+result);
        }
```

## HTML DOM(文档对象模型)

### **查找元素**：

​	**通过class查找**：var red = document.getElementsByClassName("red");

​		因为在html中，class不是唯一的，所以这里的red是一个数组，使用的时候可以这样：red[0];

​       **通过id查找**： var change = document.getElementById("change");	//id唯一

为change添加点击事件：

```javascript
		change.onclick = function() {
            //需要执行的代码
        }
```

​	**通过标签名查找**：var allP = document.getElementsByTagName("p");		//这里allP也是数组

​	**通过name属性查找**：var nameP = document.getElementsByName("firstP");	//这里nameP是数组

​	**获取最终样式**：getComputedStyle(box, null).属性   兼容火狐，google，不兼容IE低版本。

​				   box.currentStyle.属性    兼容IE低版本，不兼容火狐，google。

```javascript
    /**
     * 获取元素样式兼容
     * @param {*} ele 目标元素
     * @param {*} type  目标元素样式
     */
    function getStyle(ele, type) {
        if (ele.currentStyle) {	//在IE低版本浏览器中，ele.currentStyle为true，在google、火狐浏览器中为undefined，所以在IE浏览器中使用 ele.currentStyle[type]
            return ele.currentStyle[type];
        } else {	//在google、火狐浏览器中使用 getComputedStyle(ele, null)[type]
            return getComputedStyle(ele, null)[type];
        }
    }
```

​	**querySelecter与querySelecterAll**：

​		querySelector返回的是找到的元素中的第一个; 

​		querySelectorAll找到选择器选中的所有的元素,返回的是数组。

```javascript
		var query = document.querySelector("p");
        console.log(query);
        var query1 = document.querySelectorAll("p, span");
        console.log(query1);
```

### 使用innerHTML更改元素内容

```javascript
		var city = document.getElementById("city");
        var cityStr = "郑州,濮阳,信阳,荥阳,开封,洛阳,南阳,安阳";
        var cityArr = cityStr.split(",");
        console.log(cityArr);
        for (var i = 0; i < cityArr.length; i++) {
            city.innerHTML += "<option>" + cityArr[i] + "</option>"
        }	//innerHTML可以识别html标签
```

### 更改属性

1. 元素.属性	获取元素的属性，给其赋值直接修改属性

2. 元素.getAttribute("属性")，用于获取属性；
   元素.setAttribute("需要修改的属性","修改后的属性值")。

   ```javascript
   	<img src="images/b1.jpg" alt="图片">
       <script>
           var img = document.getElementsByTagName("img")[0];
           console.log(img);
           console.log(img.src);
           img.onclick = function() {
               img.src = "images/b2.jpg";
           }
           console.log(img.getAttribute("alt"));
           img.setAttribute("alt", "我是图片")
           console.log(img.getAttribute("alt"));
       </script>
   ```

## DOM节点操作

### 节点之间的层次关系

父节点：parentNode；

子节点：childNodes和children
		childNodes的节点内容包括空格、换行、文本、注释和标签
		children的节点内容只包含标签，但在ie8及以下会包含注释；

第一个子节点和最后一个子节点：firstChild和lastChild
		二者节点内容和childNodes相同；

### 创建新节点

var btn = document.createElement("button");	创建一个button节点
var btnContent = document.createTextNode("按钮")；	创建节点内容
btn.appendChild(btnContent);		将节点内容放入button节点

创建节点的时候，如果节点需要事件，则在创建节点的时候就给节点创建事件。

### 替换节点

对象.replaceChild(新节点，需要替换的节点);

### 删除节点

对象.removeChild(需要删除的节点);

### 兄弟节点

obj.nextSibling;	obj的下一个兄弟节点；
obj.previousSibling;		obj的上一个兄弟节点；
obj.nextElementSibling和obj.previousElementSibling也表示下一个兄弟节点和上一个兄弟节点，但他们之间存在兼容性。"

### 插入节点（indertBefore）

insertBefore(new, old); 在节点之前添加一个新节点，new表示添加的节点，在old之前添加节点new。

### 判断有无子节点

list.hasChildNodes();    如果如果list有子节点，则返回true，否则返回false。

### 克隆（clone）

​	cloneNode();  克隆   默认为false。只复制标签，不复制内容，改为true可复制内容; 
使用方法：var first = list.children[0];
 		   var copy = first.cloneNode(true);
 		   list.appendChild(copy); 
如果直接在list上添加first,则原有的list.children[0]就变成了list.children[1],而list.children[0]到了list的最后一位。

## 事件对象

### 注册事件

1. 直接给dom对象设置属性，只能给对象设置一个属性，如果设置多个事件处理函数，则最后的生效；
2. 给html标签设置属性，（若法1和法2同时使用，则法1生效）；
3. 事件注册
   绑定事件监听函数
   addEventListener("click", fun, false);  兼容火狐、google、ie9；
   attachEcent("onclick", fun);  兼容ie8及以下。
   绑定事件监听函数可以和前面两个同时使用 

### 删除事件

1. btn.onclick = null;   将事件置空，删除事件，可以使用在火狐，google，ie所有浏览器，但不能删除通过绑定监听函数设置的监听事件
2. removeEventListener   删除事件，兼容火狐，google，ie9

### 修改this的指向 

#### call函数

​	fun.call(参数1，参数2， 参数3， ...)
		 执行fun函数，并且将参数1的值赋给this，参数2，参数3作为实参传递给形参。

#### apply函数

​	fun.apply(参数1，[参数2， 参数3， ...])
		 执行fun函数，并且将参数1的值赋给this，参数2，参数3作为实参传递给形参，以数组形式传递。

## 事件委托

### 事件流

1. 捕获：查找目标元素；
2. 目标：执行目标的事件；
3. 冒泡：依次执行祖先元素的事件。
   onmouseenter和onmouseleave不支持冒泡；
   onmouseover和onmouseout支持冒泡。

### 事件对象

1. event
           属性target:可以判定当前点击的目标对象  火狐
           谷歌:
               target
               srcElement

2. 在IE低版本 event不兼容

      window.event
      srcElement
      要想获取到目标对象

      3.事件委托

​    将对自己的操作委托给父元素去执行

```javascript
		//box	是父元素
		box.onclick=function(event){
            //事件对象的兼容
            var eve=event||window.event;
            //获取的是目标对象
            var target=eve.target||eve.srcElement;
            //	target是当前点击的对象
        }
```

​	在事件委托的时候，鼠标点击的对象有很多中情况，我们要找到我们需要的那个对象；

​	解决方法：
		若target为当前点击的对象，可能有ul,li,h2,p,span,i ；
		需要点击li里面的内容，li改变样式，点击ul没有变化；
		点击的时候需要找到li
		下面的函数传参
		var target = function getTarget(target, “tagName”, “LI”, “UL“)；
		target表示我们点击的事件源，tagName表示查找的属性，LI为属性值，UL为结束条件。
		如果target不是UL，证明点击的不是ul，继续查找，如果target[tagName]等于"LI",则证明查找到了li，直接返回target，否则继续查找父节点，直到查找到UL，此时代表没有找到，返回undefined。

```javascript
		function getTarget(target, attr, value, end) {
            while (target != end) { //如果鼠标点击的是end，则直接结束
                if (target[attr] == value) {    //如果点击的对象的attr属性值为value，则返回该对象
                    return target;
                }
                target = target.parentNode; //否则查找其父节点
            }
        }
```

### 事件委托的优势

​	以ul>li*10为例：

​	    将对li的事件 委托给ul去执行
            dom数量减少
            函数数量减少
            对新增加的元素也是生效的

​	原理：基于事件冒泡
		减少函数数量
		减少dom与js的关联
		可以动态添加与删除元素

## 阻止浏览器的默认行为及阻止事件冒泡

```javascript
        /**
         * 取消冒泡
         * @param {事件} e 
         */
        function cancelBubble(e){
            if(e.stopPropagation){
                e.stopPropagation();
            }else{
                e.cancelBubble=true;
            }
        }
        /**
         * 阻止浏览器默认行为
         * @param {事件} e 
         */
        function preventDefault(e){
            if(e.preventDefault){
                e.preventDefault();
            }else{
                e.returnValue=false;
            }
        }
```

## 事件对象

在pc端，用户跟计算机进行交互就是通过鼠标和键盘，那我们怎样获取鼠标和键盘上的信息呢，通过在事件对象上的button和keycode获取。

### event.button  检测按下的鼠标键

​	可能的值： 
		0 按左键 
		1 按滚轮键 
		2 按右键 
		3 按左右键 
		4 按中间键 
		5 按左键和中间键 
		6 按右键和中间键 
		7 按所有的键 
	这个属性仅用于onmousedown, onmouseup事件。
	对其他事件，不管鼠标状态如何，都返回 0（比如onclick）。

### event.keyCode  检测键盘事件相对应的内码

这个属性用于 onkeydown, onkeyup, 和 onkeypress 事件。 

​	语法： event.keyCode[ = keyCode] 
	可能的值： 
		这是个可读写的值，可以是任何一个Unicode键盘内码。如果没有引发键盘事件，则该值为 0 。

## 常用DOM事件

### window事件

| 方法     | 描述                                    |
| -------- | --------------------------------------- |
| onload   | 当网页加载完毕时发生                    |
| onresize | 事件会在窗口被调整大小时发生。          |
| onscroll | onscroll 事件在元素滚动条在滚动时触发。 |

### 鼠标事件

| 方法                       | 描述                                   |
| -------------------------- | -------------------------------------- |
| onclick、ondblclick        | 当用户单击或者双击元素时触发           |
| oncontextmenu              | 在用户点击鼠标右键打开上下文菜单时触发 |
| onmousedown、onmouseup     | 鼠标按键被按下或松开                   |
| onmousemove                | 鼠标移动                               |
| onmouseover、onmouseout    | 鼠标移到某元素之上或者从某元素移出     |
| onmouseenter、onmouseleave | 效果同上,但是该事件不会冒泡            |

### 键盘事件

| 方法       | 描述                 |
| ---------- | -------------------- |
| onkeydown  | 键盘按键被按下       |
| onkeypress | 键盘按键被按下并松开 |
| onkeyup    | 键盘按键被松开       |

### 表单事件

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| onblur   | 元素失去焦点时触发                                           |
| onchange | 该事件在表单元素的内容改变并失去焦点时触发( <input>, <keygen>, <select>, 和 <textarea>) |
| onfocus  | 元素获取焦点时触发                                           |
| onreset  | 表单重置时触发                                               |
| onselect | 用户选取文本时触发 ( <input> 和 <textarea>)                  |
| onsubmit | 表单提交时触发                                               |

### 表单对象

事件：onresetonsubmit方法：form.reset()form.submit()当表单提交的事件处理程序返回假值，则阻止提交。

### 复选框的属性

checkboxObj.checked = true;表示选中
checkboxObj.checked = false;表示未选中

### 下拉菜单的属性、事件

1. selectObj.selectedIndex ： 返回选中option的索引
2. optionObj.selected ： 返回选择状态
3. selectObj.value
4. selectObj.onchange

## 全局函数&DOM对象的宽高、位置属性&Event对象的位置

### 全局函数

| 方法                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| isFinite()                     | 检查某个值是否为有穷大的数。                                 |
| isNaN()                        | 检查某个值是否是数字。                                       |
| Number()                       | 把对象的值转换为数字。                                       |
| parseFloat()                   | 解析一个字符串并返回一个浮点数。                             |
| parseInt()                     | 解析一个字符串并返回一个整数。                               |
| String()                       | 把对象的值转换为字符串。                                     |
| eval()                         | 计算 JavaScript 字符串，并把它作为脚本代码来执行。           |
| getComputedStyle(element,null) | 获取元素节点最终计算好的样式,结果为对象(注意IE8及以下不支持，IE8及以下用dom对象.currentStyle) |

### DOM对象宽高、位置属性

- **clientWidth和clientHeight(只读)**
   该属性指的是元素的可视部分宽度和高度，即**padding+content**，如果没有滚动条，即为元素设定的高度和宽度，如果出现滚动条，滚动条会遮盖元素的宽高，那么该属性就是其本来宽高减去滚动条的宽高。
- **clientTop和clientLeft(只读)**
   通常情况下等于**左边和上面的边框宽度**,很少使用
   	对于内联元素，clientLeft和clientTop总是0；
- **offsetWidth和offsetHeight(只读)**
   这一对属性指的是元素的**border+padding+content**的宽度和高度，该属性和其内部的内容是否超出元素大小无关，只和本来设定的border以及width和height有关。
- **offsetLeft和offsetTop(只读)**
   说到这对属性就需要说下offsetParent,所谓offsetParent指的是当前元素的**离自己最近的具有定位的**（position:absolute或者position：relative）**父级元素**（不仅仅指的是直接父级元素，只要是它的父元素都可以），该父级元素就是当前元素的offsetParent，如果从该元素向上寻找，找不到这样一个父级元素，那么当前元素的offsetParent就是body元素。
   	offsetLeft和offsetTop指的是**当前元素，相对于其offsetParent左边距离和上边距离。**
- **scrollWidth,scrollHeight(只读)**
   是元素的**内容区域加上它的内边距再加上任何溢出内容的尺寸**；
   	如果内容没有溢出,在IE7是取不到的。
- **scrollTop和scrollLeft(可读写)**
   指的是当元素其中的内容超出其宽高的时候，**元素被卷起的高度和宽度**。
- **offsetPartent**
   box.offsetPartent指的是距box最近的具有定位属性的元素。


### 偏移量 

#### 获取和设置浏览器滚动的距离（窗口卷起高度）

```javascript
//获取scrollTop值 （完美的获取scrollTop 赋值短语 ）： 
var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
```

```javascript
/**
 * 获取窗口卷起高度
 */
function getScrollTop() {
    return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;
}
/**
 * 设置窗口卷起高度
 * @param {窗口卷起高度} top 
 */
function setScrollTop(top) {
    document.documentElement.scrollTop = top;
    window.pageYOffset = top;
    document.body.scrollTop = top;
}
```

#### 获取元素相对于浏览器窗口的偏移量

​	**getBoundingClientRect()** 返回一个矩形对象，包含四个属性：left、top、right和bottom。分别表示元素距离浏览器左上角的距离，无兼容。

​	**clientX()和clientY()**:鼠标相对于浏览器左上角的距离（可视区域）。

## JavaScript BOM

### window对象

```javascript
// 获取当前窗口宽度和高度
var width=window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
  var height=window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
```

- window.open(url,target);    打开新窗口 此方法有多个参数，常用的是两个参数的 window.open("http://www.baidu.com","_blank") 这种弹框容易被浏览器当作广告拦截
- window.close();    关闭窗口 有兼容性问题，支持IE
- window.alert("message");    弹出一个具有OK按钮的系统消息框，显示指定的文本
- window.confirm("Are you sure?");    弹出一个具有OK和Cancel按钮的询问对话框，返回一个布尔值
- window.prompt("What's your name?", "Default");    提示用户输入信息，接受两个参数，即要显示给用户的文本和文本框中的默认值将文本框中的值作为函数值返回

| 方法     | 描述                   |
| -------- | ---------------------- |
| onload   | 所有资源加载完毕后触发 |
| onresize | 浏览器窗口有变化时触发 |
| onscroll | 浏览器窗口有滚动时触发 |

### 组成BOM的对象——history对象

- 存放浏览器当前窗口的的访问历史
- 常用方法
  **window.history.back();** //无参数，回退到上一个窗口
  **window.history.forward();** //无参数，跳转到下一个窗口
  **window.history.go(n);** //当n = 1时，等价于forword();当n = -1时，等价于back();当n = 0时，刷新当前页面
  **window.history.length** //可以查看历史中的页面数（history对象中存储的页面数）

### 组成BOM的对象——location对象

- 用于获得当前页面的地址 (URL)信息、页面重定向等场景
- 常用属性和方法（这些属性都是可以修改的，修改会导致页面重载）
  **location.href** //当前载入页面的完整URL，如http://www.somewhere.com/pictures/index.htm **location.protocol** //URL中使用的协议，即双斜杠之前的部分，如http 
  **location.host** //服务器的名字，如www.wrox.com:8080
  **location.hostname** //通常等于host(但host里面带端口，hostname不带)
  **location.port** //URL声明的请求的端口，默认情况下，大多数URL没有端口信息，如8080 **location.pathname** //URL中主机名后的部分，如/pictures/index.htm 
  **location.search** //执行GET请求的URL中的问号后的部分，又称查询字符串，如?param=xxxx ,参数的传递**location.hash** //如果URL包含#，返回该符号之后的内容，如#anchor1 
  **location.assign("http:www.baidu.com");** //同location.href，新地址都会被加到浏览器的历史栈中 **location.replace("http:www.baidu.com");** //同assign()，但新地址不会被加到浏览器的历史栈中，不能通过back和forward访问 
  **location.reload(true | false);** //重新载入当前页面，为false时从浏览器缓存中重载，为true时从服务器端重载，默认为false

### 组成BOM的对象——navigator对象

- 存放有关Web浏览器的信息，在检测浏览器及操作系统方面非常有用
- 常用方法
  **navigator.appCodeName** //浏览器代码名的字符串表示 
  **navigator.appName** //官方浏览器名的字符串表示 
  **navigator.appVersion** //浏览器版本信息的字符串表示 
  **navigator.cookieEnabled** //如果启用cookie返回true，否则返回false 
  **navigator.javaEnabled** //如果启用java返回true，否则返回false 
  **navigator.platform** //浏览器所在计算机平台的字符串表示 
  **navigator.plugins** //安装在浏览器中的插件数组 
  **navigator.taintEnabled** //如果启用了数据污点返回true，否则返回false 
  **navigator.userAgent** //用户代理头的字符串表示

### 组成BOM的对象——screen对象

- 存放有关显示浏览器屏幕的信息
- 常用属性：
  **availHeight**:属性返回访问者屏幕的高度，以像素计，减去界面特性，比如窗口任务栏。
  **availWidth**:属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如窗口任务栏。
  **height**:返回屏幕区域的实际高度 /*跟电脑分辨率一致*/
  **width**:返回屏幕区域的实际宽度屏幕分辨率的宽高 /*跟电脑分辨率一致*/

## json

### json对象和json字符串

json是一个键值对集合；
标准json的键需要加引号；

1. **将json字符串转化为json对象**
   JSON.parse(str) 	parse意为解析
2. **将json对象转化为json字符串**
   JSON.stringify(obj)

在IE低版本,进行json解析的时候报错,需要引入json2.js文件

## js中的错误与异常

代码中的错误和异常会阻断代码继续运行，我们不希望一些不影响页面效果的错误代码影响代码的执行，所以需要对可能发生错误和异常的代码进行捕获。

```javascript
	   try{
          //此处是可能会发生异常的代码，捕获异常
            // console.log(target.className);//eferenceError: target is not defined
            var target;
            if(!target){
                throw "target的值没有定义";
            }
            console.log(num)   //ReferenceError: num is not defined; 
        //    console.log()，//SyntaxError: illegal character
        }catch(e){
            //抛出异常
            console.log(e);
        }finally{
            //无论有无异常，此处代码都会执行
            console.log("无论是否有异常发生,此处的代码都会运行")
        }
```

## 函数

### typeof运算符的返回值有哪些

-  null返回的是object
- undefined:undefined
- boolean:boolean
- number返回的是number
- 函数返回的是function

### 创建对象

1. new Object();
2. json对象;
3. 构造函数;
       普通函数和构造函数，没有本质区别，通常情况下，构造函数的首字母大写。
       调用方式的不同决定了函数是普通函数还是构造函数。
   比如函数名fun();
       new fun();fun是构造函数，里面的this指向是当前对象。
       fun();fun是普通函数，里面的this指向的是window。

### 函数中的属性

​	length：形参的数量

在函数体内部,可以使用arguments获取形参,arguments不是数组但是可以使用数组的方式去获取实参

### 构造函数

​    new fun();fun是构造函数，里面的this指向是当前对象。一旦使用new运算符，就是创建对象，函数中的this指向的是当前对象，可以通过this给当前对象添加属性和方法，够着函数中没有返回值，默认返回的是this。

​	**构造函数中的返回值**

​	一般情况下，构造函数中没有return语句，默认返回的是this（当前对象）；
	如果构造函数中有返回值，返回值类型为：
		1.基本数据类型；
		2.引用数据类型；
			如果return的是基本数据类型，构造函数返回的依旧是this；
			如果return的是引用数据类型，会覆盖this，返回的就是引用数据类型。

​	**对象的方法与属性**

1. 直接用for...in...可遍历对象的属性和方法；
2. 给对象添加或修改属性和方法，直接点属性和方法即可；
3. 删除属性和方法用delete对象的属性和方法。

## 面向对象

### 原型对象

```javascript
function Student(name, age) {
	this.name = name;
    this.age = age;
}
var stu = new Student("tom", 18);
// Student 函数对象，构造函数
// stu 普通对象，实例对象
// 通常情况下使用的是instanceof方法来判断stu继承谁
```

​	函数对象上具有原型对象prototype；
	主要是用来实现继承的；
	在通过new fun();创建的普通对象可以共享fun的原型对象的属性和方法；

​	普通对象上有__ proto __属性； 该属性指向的是构造函数的prototype（原型对象）；

```javascript
// 原型链：按照stu.__proto__.__proto__.__proto__.__proto__查找，找到的结果可能为null
```

### 封装、继承、多态

#### 继承

1. **原型链继承**
   把父类的实例给子类的原型child.prototype=new Parent()；
   优点：
   	可以获取原型对象以及构造函数里面的属性和方法；
   缺点：
   	(1)修改了obj1的引用数据,obj2上的也会发生变化；
   	(2)创建子类的实例的时候,无法向父类的构造函数传递参数。
2. **借用构造函数继承**
   使用call方法,在子函数的内部添加Parent.call(this,参数);,可以实现多继承,即多个call；
   核心：
   	相当于复制了一份父类的属性和方法；
   优点：
   	1.解决了子类共享父类的属性和方法的问题；		
   	2.创建子类实例的时候,可以给父类的构造函数传递参数。
   缺点：
   	无法实现复用:每一个子类都有自己的方法,实例过多,内存消耗过大	；
   	无法取到父元素的原型上的内容。
3. **组合继承**
   1.将子元素共享的方法写入父元素的原型,根据继承的特征,子元素想访问到该方法,需要将子元素的原型指向父元素的实例
   		Child.prototype=new Parent();	
   2.要想给父元素传递参数,需要借用父元素的构造函数
   			Parent.call(this,参数)	
   优点：
   	1.不存在引用属性共享的问题;
   	2.可以传递参数;
   	3.方法可以复用(共享)。
   缺点：
   	会出现两组父元素的属性,一组在child的实例上,一组在child的原型上。
4. **组合寄生式继承(写法繁琐,但是完美)**
   1.将子元素共享的方法写入父类的原型；
   2.借用构造函数即在子元素的构造函数中调用call方法向父类传递参数,拿到了一份父类的属性；
   3.继承原型上的方法,不再是简单的将子元素的原型指向父元素的实例；
   		(1)利用中间函数,该函数仅仅是为了复制父类的原型:函数中创建一个对象,将该对象obj的构造函数的原型指向parent的原型,然后return obj；
   		(2)因为obj上只有父类的原型属性和方法,所以Child.parototype=obj;
   			防止修改构造器,修正子类的构造器即  Child.constructor=Child;

##### 对象继承-总结

- 原型上只有原型的属性和方法；
- 实例上即有原型的属性和方法也有构造函数中的属性和方法；
- 所以在寄生组合继承的时候复制一份父元素的原型,赋值给子元素的原型；
- 为什么不将父元素的原型直接赋值给子元素,因为继承Parent的可能有很多个,如果直接赋值,那么子元素之间会相互影响；

### 闭包

1. 作用域链
   	函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是调用时决定的。因此函数对象中存放的不仅有函数的代码逻辑，还必须引用当前的作用域链。
   	函数对象通过作用域相互关联起来，函数体内部的变量都可以保存在函数作用域内。这种特性叫做闭包。
   	我们在开发中，任何一个js函数都是对象，都关联到函数作用域链，它们都是闭包。
   	但是当闭包的调用和定义不在同一个作用域链中时，事件将变得非常微妙。
   	闭包的调用和定义不在一个作用域链中时，返回的结果确实是相同的，还是那句话，函数的作用域是在定义时决定的，而不是调用时决定的。
   	利用这个特性，函数外部就可以访问函数内部的变量。
2. 由于闭包在每次调用时都会产生新的对象，这个新的对象如果被函数外部的变量引用，就不能在函数执行完毕后被js垃圾 回收机制回收，就会一直占用内存，因此闭包有个缺点，就是会造成内存的浪费。
3. 闭包的用途就是可以在函数外部访问函数内部的变量；
   闭包的缺点就是会造成内存浪费。
4. this总是指向调用它的那个对象，只能在函数内部调用，如果外部想要调用this，可以使用变量记录this。

### 自运行函数

1. (function(形参){})(实参)
2. !function(形参){}(实参)
3. +function(形参){}(实参)

## 正则表达式

### 正则表达式的定义

1. 字面量的形式；

2. 创建RegExp对象的形式。

   区别：字面量形式无法传递参数，创建对象形式可以传递参数;
   	    在字面量形式中使用转义字符"\",在创建对象中需使用"\ \";
   	    使用字面值的形式,是不能使用变量或者函数的。
   		例如:var num1=1;var reg1=/num1/ 并不能等价于 var reg1=/1/;
   		使用对象 var reg2=new RegExp(num1)  等价于reg=/1/；

### 正则的验证

1. test()方法
   返回的是boolean,如果匹配则返回true,如果不匹配则返回false。
2. exec()方法
   如果满足返回的是数组,如果不满足,返回的null;返回的数组的第0个值就是满足正则的子字符串	可以通过循环获得满足满足正则的所有的子字符串,必须指定全局匹配g才可以循环,否则会陷入死循环。

### 字符类

| 字符   | 匹配                                            |
| ------ | ----------------------------------------------- |
| [...]  | 方括号内的任意字符                              |
| [^...] | 不在方括号内的任意字符                          |
| .      | 除换行符和其他Unicode行终止符之外的任意字符     |
| \w     | 任何ASCII字符组成的单词，等价于[a-zA-Z0-9_]     |
| \W     | 任何不适ASCII字符组成的单词，等价于[^a-zA-Z0-9] |
| \s     | 任何Unicode空白符                               |
| \S     | 任何非Unicode空白符的字符，注意\w和\s不同       |
| \d     | 任何ASCII数字，等价于[0-9]                      |
| \D     | 除了ASCII数字之外的任何字符，等价于[^0-9]       |
| \b     | 匹配边界,边界表示的是前面和后面的字符不全是\w   |

### 量词

| 字符  | 含义                                                      |
| ----- | --------------------------------------------------------- |
| {n,m} | 匹配前一项至少n次，但不能超过m次                          |
| {n,}  | 匹配前一项n次或者更多次                                   |
| {n}   | 匹配前一项n次                                             |
| ?     | 匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0,1} |
| +     | 匹配前一项1次或多次，等价于{1,}                           |
| *     | 匹配前一项0次或多次，等价于{0,}                           |

### 贪婪的、惰性的量词

​	贪婪先看整个字符串是不是一个匹配，如果没匹配去掉最后一个字符，再次尝试，直到发现一个匹配或者字符串不剩任何字符惰性量词(?)的话，先看字符串第一个字母是不是匹配，如果不匹配，再读入下一个字符，组成两个字符组成的字符串，然后再看这个字符串匹配不，直到发现一个匹配或者整个字符串都检查过也没有匹配。

### 候选

​	正则表达式的语法还包括指定选择项。字符“|”用于分隔供选择的字符。
	例如，/ab|cd|ef/可以匹配字符串“ab”，也可以匹配“cd”和“ef”。
	注意：选择项的尝试匹配次序是从左到右，直到发现匹配项。如果左边的选择项匹配，就忽略右边的匹配项，即使它产生更好的匹配。因此/a|ab/ 匹配字符串“ab”，只匹配到“a“

### 分组（正则表达式中的圆括号的作用）

1. 是单独的项组合成子表达式，以便可以像处理一个独立的单元那样用“|”、“*”、“+”或者“？”等来对单元内的项进行处理。
   例如： /java(script)?/可以匹配字符串“java”，其后可以有“script”也可以没有。/(ab|cd)+|ef/可以匹配ef，也可以匹配ab或cd的一次或多次重复。
2. 是在完整的模式中定义子模式。当一个正则表达式成功的和目标字符串相匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分（后续部分可以看到如何取得这些匹配的子串）。
   例如：/[a-z]+\d+/;     //匹配一个或多个小写字母后跟随了一个或多个数字但是假定我们真正关心的是每个匹配尾部的数字，那么如果将模式的数字放在括号中（/[a-z]+(\d+)/），就可以从检索到的匹配中抽取数字了，之后我们会有详尽的解释。

### 引用

​	是允许在同一正则表达式的后部引用前面的子表达式。这是通过在字符“\”后加一位或多位数字来实现的。这个数字指定了带圆括号的子表达在正则表达式中的位置。例如,\1引用的是第一个带圆括号的子表达式，\3引用的是第三个带圆括号的子表达式。注意，因为子表达式可以嵌套另一个子表达式，所以它的位置是参与计数的左括号的位置。
	例如：/<(h1)>\w+<\/\1>/.test("<h1>title</h1>");    //其中h1可以用\1来指代。
	注意：对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。

### 分组但不引用

圆括号还可以只分组，不引用。
但是他不是以（）进行分组，而是以(?:  )来进行分组。
比如，/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/;这里，子表达式(?:[Ss]cript)仅仅用于分组,这种改进的圆括号并不生成引用，所以在这个正则表达式中，\2引用了与（fun\w*）匹配的文本。

### 前瞻

| 字符  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| ^     | 匹配字符串的开头，在多行检索中，匹配一行的开头               |
| $     | 匹配字符串的结尾，在多行检索中，匹配一行的结尾               |
| \b    | 匹配一个单词的边界，简言之，就是位于字符\w和\W之间的位置，或位于字符\w和字符串的开头或者结尾之间的位置（但需要注意，[\b]匹配的是退格符） |
| \B    | 匹配非单词边界的位置                                         |
| (?=p) | 正向前瞻，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符 |
| (?!p) | 负向前瞻，要求接下来的字符不与p匹配                          |

使用前瞻可以让特定的字符分组出现在另外一个字符串之前，才去捕获它。
名称	表达式	含义
正向前瞻	exp1(?=exp2)	匹配后面是exp2的exp1
负向前瞻	exp1(?!exp2)	匹配后面不是exp2的exp1

```javascript
var patt = /^(?![0-9]+$)(?![a-zA-Z]+$)[\w]*$/; //不能为纯数字或纯字母
```

### 用于模式匹配的String方法

- replace： 默认是只替换第一次查找到的；
     要想全部替换，可以给正则添加g，全局匹配。

- search：返回的是第一次出现的下标，忽略g；
         如果没有找到，则返回的是-1.

- match：将匹配的结果输出
         如果是全局匹配，则将所有的匹配结果输出

     ```javascript
     var str2 = "username=xiaoming; userpwd=1234";
     var patt2 = /(^| )username=([^;]*)(;|$)/;
     console.log(str2.match(patt2));	//Array(4) [ "username=xiaoming;", "", "xiaoming", ";" ]
     /*	(^| )：表示头是开始或者空格
     	([^;]*)：表示不是;的0个或多个
     	(;|$)：表示尾是;或$
     */
     var str = "username=xiaoming; userpwd=1234";
     var patt = /(^| )userpwd=([^;]*)(;|$)/;
     console.log(str.match(patt));	//Array(4) [ "userpwd=1234", " ", "1234", "" ]
     ```

- split：分割符号可以使用正则

## 产生undefined的情形

1. 变量声明为赋值，默认返回的undefined；
2. 函数没有返回值，默认返回的是undefined；
3. 访问对象中不存在的属性，返回的是undefined。

## this的指向

1. 给dom对象添加事件的时候
   (1)以属性的形式添加
   	btn.onclick = fun;fun函数中的this指向的是dom对象btn；
   (2)事件监听
   	btn.addEventLitener("click", fun, false);fun中的this指向的是btn；
   	btn.attachEvent("onclick", fun);fun中的this指向的是window；
2. 函数的调用
   fun();函数中的this指向的是window；
   new fun();函数中的this指向的是当前的对象；
3. 定时器
   setTimeout(fun, 2000); fun中的this指向的是window；

## Javascript字符串编码函数 、 cookie（客户端）

### Javascript字符串编码函数 

**字符串编码函数：**

1. escape
2. encodeURI
3. encodeURIComponent

**对应的解码函数：**

1. unescape
2. decodeURI
3. decodeURIComponent

**下面列出了这三个函数的安全字符（即函数不会对这些字符进行编码）**

escape（69个）：*/不会对@+-._0-9a-zA-Z编码*

encodeURI（82个）：!#$&'()*+,/:;=?@-._~0-9a-zA-Z*

encodeURIComponent（71个）：!'()*-._~0-9a-zA-Z

### 客户端COOKIE

**javascript中location.href可以实现页面的自动跳转**

设置COOKIE的语法：

```javascript
// 设置COOKIE
document.cookie = “user=Rose”;
document.cookie = “pw=123”;
document.cookie =  “user=”+ escape('张三');
// 如果cookie不设置过期时间，等同于会话cookie，关闭浏览器后cookie会消失，要想cookie不消失，需要给cookie设置过期时间
var date = new Date();
date.setDate(date.getDate() + 1);
document.cookie = "username=xiaoming;expires=" + date.toGMTString();
// 使用expires设置cookie过期时间
// 删除cookie即把过期时间设到过去
var date = new Date();
date.setDate(date.getDate() - 1);
document.cookie = "username=xiaoming;expires=" + date.toGMTString();
// 修改cookie即覆盖cookie，覆盖后如果不设置过期时间还是会和会话cookie一样
document.cookie = "username=zhangsan";
/*path：指定可访问cookie的路径
在设置cookie时，如果不添加path，则默认只能在当前目录下访问cookie，如需要在其它目录下访问，需要设置path
document.cookie="userId=320; path=/shop";
就表示当前cookie仅能在shop目录下使用。
如果要使cookie在整个网站下可用，可以将cookie_dir指定为根目录，例如：
document.cookie="userId=320; path=/";*/
// domain=cookieDomain
// domain：可实现跨主机（域名）访问，指定可访问cookie的主机名
```

​	在cookie的名或值中不能使用分号（;）、逗号（,）、等号（=）以及空格。在cookie的名中做到这点很容易，但要保存的值是不确定的。如何来存储这些值呢？方法是用escape()函数进行编码，它能将一些特殊符号使用十六进制表示，例如空格将会编码为“20%”，从而可以存储于cookie值中，而且使用此种方案还可以避免中文乱码的出现。

​	toGMTString() 方法可根据格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果。

# PHP

## PHP基础

1. 变量定义		$变量名

	. 常量定义		define("username","admin",true); 
   	define(常量，常量值，boolean);
    boolean默认取值false，表示区分大小写，当改为true后，表示不区分大小写；

3. 字符串中使用点进行拼接，字符串的长度使用 strlen；

4.  php中的elseif之间不能加空格 ；

5. 创建数组，使用array()方法 ;访问数组  $arr[n]  n是下标 ;数组的长度使用的是count(arr):统计数组的长度 ;

   ```php
   	// 数值数组
       foreach ($arr as $val) {
           echo $val;  //$val 表示数组中每个元素的值
       }
       echo "<br>";
       // 关联数组
       foreach ($arr as $key => $val) {
           echo $key.":".$val;
           //$key表示的是数组中的每个键
           // $val表示的是数组中的每个键对应的值
       }
   ```

6. 超级全局变量(1)获取当前的目录:
   (1) $_SERVER["PHP_SELF"];
   (2)$_REQUEST[];获取form表单提交的数据,post或者get请求;
   (3)$_GET[];
   (4)$_POST[];

7. 魔法常量
   	__ LINE__
           __ FILE__

8. 常用的方法
   echo 输出
               isset() empty()返回的是boolean值,用在逻辑判断；
               isset():如果传递了值,则返回true；

## PHP表单验证

preg_match() 函数用于进行正则表达式匹配，成功返回 1 ，否则返回 0 。

```php
		if (!preg_match("/^[a-zA-Z ]*$/",$name))  // 
        {
            $nameErr = "只允许字母和空格"; 
        }
```

trim() 函数移除字符串两侧的空白字符或其他预定义字符。

## PHP常见问题

- header("Content-type: text/html; charset=utf-8");   //防止中文乱码
- header('location:test.php?nameErr=' . $nameErr);    //页面重定向
- header("Access-Control-Allow-Origin: *");     // php实现跨域

## PHP连接数据库

```php
<?php
    $username = "root";
    $userpwd = "root";
    $dbname = "bookshop";
    $servername = "localhost";
    $conn = new mysqli($servername, $username, $userpwd, $dbname);
    if($conn->connect_error){//验证数据库连接是否成功,$conn->conner_error:返回数据库连接的错误类型
        die("数据库连接失败");		//die(): 函数输出一条消息，并退出当前脚本。
    }
?>
```

```php
<?php
    $id = $_GET["id"];
    include("../inc/dbconnect.php");	//导入php代码
    $sql = "delete from book where id=$id";		//定义sql语句
    $conn->query($sql);		//执行sql代码
    header("location:bookList.php");	//页面重定向
?>
```

**相关知识点**

```php
	1、 die(): 函数输出一条消息，并退出当前脚本。
	2、 $conn->conner_error :  返回数据库连接的错误类型
	3、 $result = $conn->query(SQL语句) : 用SQL语句查询指定表中信息，并返回记录集(查询到的记录的集合)
	4、 $result->num_rows :  返回查询到的记录的条数（要和字段区分开）
	5、 $row = mysqli_fetch_assoc($result) : 从结果集中取得一行(一条记录)转换为"关联数组"：
        	mysqli_fetch_assoc将查询结果转换为关联数组，特别想正则的exec方法
	    $result : 假想成是一个表格：  假如结果集有两行，三个字段
	    id    bName   price
	    1     html5    100
	    2     css3      22
	    3     js        11
	    第一次执行： $row = mysqli_fetch_assoc($result)
	    $row = array("id"=>"1","bName"=>"html5", "price"=>"100")
	    第二次执行： $row = mysqli_fetch_assoc($result)
	    $row = array("id"=>"2","bName"=>"css3", "price"=>"22")
    6、  date_default_timezone_set('PRC');//中国时区
```

## 图片上传

1. html
   	form表单操作：
   		method指定的是post；
   		设置enctype="multipart/form-data";
   	给图片指定name属性；比如“pic”.

2. php
   	引入upload.php(自己写好的php文件)；
   	获取传递过来的文件；

   ```php
   $file = $_FILES["pic"]
   ```

   ​	调用upload.php里面的upload方法；

   ```php
   $res=upload($file,url);  //url是将图片传递到那个位置
   $res["msg"];	// 可以获取图片的名字
   ```

   ## 服务器端COOKIE

   cookie 常用于识别用户。cookie 是一种服务器留在用户计算机上的小文件。每当同一台计算机通过浏览器请求页面时，这台计算机将会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。

   ```php
   // 1.创建cookie
   //setcookie(name, value, expire, path, domain); name是cookie名，value是cookie值，expire是过期时间
   setcookie("user", "runoob", time()+3600);	// time是当前时间
   setcookie("user", "", time()-3600);	// time是当前时间，取消cookie，将时间设为过期时间
   // 获取cookie的值
   $_COOKIE["user"];
   ```

## 服务器端SESSION会话

1. 使用session之前必须先打开session，session_start(); 
2. 添加session，￥_SESSION["username"] = $username; 
3. 获取session会话，$_SESSION["username"]; 
4. 销毁session
   (1).销毁指定的session会话：unset($_SESSION["username"]); 
   (2).销毁所有的session会话，session_destroy(); 

## PHP-smarty模板引擎

smarty是采用php写的一个模板引擎，设计的目的是要将html代码与php代码分离。

### smarty模板引擎使用步骤

1. 将smarty文件夹拷入项目中；
2. 在项目的根目录中新建一个smarty的配置文件，init.inc.php；
3. 在根文件夹中创建两个文件夹：templates，templates_c；
4. 把mark.html文件放在templates文件夹下；
5. 在根目录下创建与mark.html相对应的mark.php；
6. 在根目录下创建inc文件夹，并在内部创建dbconn.php（数据库连接）；
7. 在mark.php内引入dbconn.php、init.inc.php，并完成数据的查询，并用$smarty->assign()和
   $smarty->display把数据库传给指定的模板文件（*.html）；
8. 在模板文件中用{}的形式，嵌入数据；
9. 测试mark.php。

```php
// init.inc.php
<?php
define("ROOT", str_replace("\\", "/",dirname(__FILE__)).'/');  //指定项目的根路径
    require ROOT.'smarty/Smarty.class.php';                        	   //加载Smarty类文件  
    $smarty = new Smarty();                                 //实例化Smarty类的对象$smarty
    /* 推荐用Smarty3以上版本方式设置默认路径,成功后返回$smarty对象本身，可连贯操作 */
    $smarty ->setTemplateDir(ROOT.'templates/')    //设置所有模板文件存放的目录
            ->setCompileDir(ROOT.'templates_c/')        //设置所有编译过的模板文件存放的目录
            ->setPluginsDir(ROOT.'plugins/')                 //设置为模板扩充插件存放的目录
            ->setCacheDir(ROOT.'cache/')                      //设置缓存文件存放的目录
            ->setConfigDir(ROOT.'configs');                   //设置模板配置文件存放的目录
    $smarty->caching = false;                                   //设置Smarty缓存开关功能
    $smarty->cache_lifetime = 60*60*24;                  //设置模板缓存有效时间段的长度为1天
    $smarty->left_delimiter = '{';                             //设置模板语言中的左结束符
    $smarty->right_delimiter = '}';                           //设置模板语言中的右结束符
    $smarty->auto_literal = false;                             //设置分隔符允许出现空格
?>
```

```php
// 静态网页（模板）中展示数据
{foreach $goods as $x=>$val}
<tr>
    <td>{$val["goodsName"]}</td>
    <td>{$val["goodsDesc"]}</td>
    <td>{$val["price"]}</td>
</tr>
{/foreach}
```

```php
// php中如何将数据传到html
$smarty->assign("goods", $arr);
$smarty->assign("len", $pageNum);
$smarty->display("page.html");
```

# AJAX

## 什么是AJAX

1. AJAX= Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）；
2. AJAX 不是新的编程语言，而是一种使用现有标准的新方法；
3. 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

## AJAX传输数据

```php
$res = $conn->query($sql);
while($row = mysqli_fetch_assoc($res)) {
    $arr[] = $row;
}
echo json_encode($arr);//返回的是json类型的字符串
    // 返回到前端json,将数据转化为json对象发送到前台页面
```

## AJAX如何使用

### 创建XMLHttpReauest对象

XMLHttoRequest是AJAX的基础。

```javascript
var xhr;
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xhr=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xhr=new ActiveXObject("Microsoft.XMLHTTP");
  }
// 选择一般只使用 xhr=new XMLHttpRequest();
```

### xhr(XMLHttpRequest )的open方法

**作用:**创建一个新的http请求，并指定此请求的方法，URL以及验证信息（比如：用户名、密码）；
**语法：**xhr.open("get/post","test.txt",true);  // 调用了open方法仅仅是设置好参数而已

1. 第一个参数是请求方式，一般使用get与post方法，与form标签的method类似；
   如果要使用post，需要添加请求头文件：

   ```javascript
   xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded;charset=UTF-8");
   ```

2. 第二个参数是请求的URL；

   ```javascript
   demo1:    xhr.open("get","getData.php",true)	
   demo2:    xhr.open("get","getData.php?key=a",true)
   demo3:    xhr.open("get","getData.php?user=mike&pw=123",true)
   demo3:    xhr.open("post","getData.php",true)
   ```

3. 第三个参数是请求是同步还是异步进行，true表示异步。

### xhr(XMLHttpRequest )的send方法

**作用：**调用了send方法后才会发出请求；
**语法：**xhr.send(data);
	demo:        xhr.send(“user=”+username+”&pw=”+pw);  //以post方式传递时	
	//get方式发送请求时:   xhr.send(null);

### XMLHttpRequest 对象的三个重要的属性

| 属性                           | 描述                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| onreadystatechange（事件属性） | 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 |
| readyState属性                 | 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化.  (还没有调用 open 方法) 1: 服务器连接已建立 (open 方法已被调用，) 2: 请求已接收  (send 已被调用。请求已经开始) 3: 交互中 ( 服务器正在发送响应) 4: 请求已完成，且响应已就绪  （响应发送完毕） |
| status属性                     | 200: "OK" 404: 未找到页面                                    |

### xhrr(XMLHttpRequest )的responseText 属性

（1）获取服务器响应数据；
（2）responseText 属性返回字符串形式的响应。

### 创建回调函数

(1)当请求被发送到服务器时，我们需要执行一些基于响应的任务；
(2)readyState 属性存有 XMLHttpRequest 的状态信息, 每当 readyState 改变时，就会触发 onreadystatechange 事件。当 readyState 等于 4 且状态为 200 时，表示响应已就绪；
(3) 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。

```javascript
xhr.onreadystatechange=function(){
  if (xhr.readyState==4 && xhr.status==200)
    {
       //接收服务器端响应数据，并用js进行处理，显示在客户端页面
       例：document.getElementById("myDiv").innerHTML=xhr.responseText;
    }
  }
```

### xhr.abort()方法：停止当前请求

### 实际运用

js中

```javascript
		btn.onclick = function() {
            var xhr = new XMLHttpRequest();
            xhr.open("get", "ajax.php", true);
            xhr.send();
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4 && xhr.status == 200) {
                    // console.log(xhr.responseText);
                    box.innerHTML = xhr.responseText;
                }
            }
        }
```

php中

```php
<?php
    echo "成功了";
?>
    // 总结将打印内容返回到js中xhr的responseText属性中
```

### 总结

AJAX实质上也是遵循Request/Server模式，所以这个框架基本的流程是：
	一、对象初始化
	二、发送请求
	三、服务器接收
	四、服务器返回
	五、客户端接收
	六、修改客户端页面内容。
	只不过这个过程是异步的。

# JSONP

## JSONP的最基本的原理是：

​	动态添加一个<script>标签，而script标签的src属性是没有跨域的限制的。
	Jsonp的执行过程如下：//以JSONP接口http://www.b.com/search.html?jsonp=jsonpCallback为例 
		1、首先在客户端注册一个callback（回调函数）, 然后把callback的名字传给服务器；
		2、服务器先生成json数据,然后以JavaScript语法的方式，生成一个function,function的名字就是传递上来的参数jsonp的值，function的参数为服务器生成好的json数据,然后把用该语法写好的内容返回给客户端。(语法：callback(json数据))；
		3、客户端浏览器，解析script标签，并执行返回的javascript文档，此时数据作为参数，传入到了客户端预先定义好的callback函数里.（动态执行回调函数）。

## JSONP和JSON的区别

JSON:
	1、JSON是一种基于文本的数据交换方式，或者叫做数据描述格式；
	2、JSON只有两种数据格式，大括号{}（对象）和方括号[]（数组）。

JSONP:
	1、JSONP(JSON with Padding)是一个非官方的协议,主要来解决跨域问题；
	2、在客户端事先定义好一个处理函数；
	3、通过script标签的src属性发起一个跨域的请求；
	4、目标文件会以函数调用的形式传回数据，触发本地处理函数的执行。数据是以函数参数的形式传递回来的。(它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问。)

## JSONP案例

​	1、网页加载时，自动进行跨域请求
	2、交互实现跨域请求。



## 例题

### 随机生成颜色

```javascript
		function randomColor() {
            var red = randomNumber(0, 255);
            var green = randomNumber(0, 255);
            var blue = randomNumber(0, 255);
            return "rgb(" + red + ", " + green + ", " + blue + ")";
        }
```

### 判断字符串中出现次数最多的字符

```javascript
// 判断字符出现次数
        function charCount(str) {
            var obj = {};
            for (var i = 0; i < str.length; i++) {
                if (obj[str[i]]) {
                    obj[str[i]]++;
                } else {
                    obj[str[i]] = 1;
                }
            }
            var max = 0;
            var arr = [];
            for (var j in obj) {
                if (obj[j] > max) {
                    max = obj[j];
                    arr = [];
                    arr.push(j);
                } else if (obj[j] == max) {
                    arr.push(j);
                }
            }
            return {
                character: arr,
                count: max
            }
        }
        var str = "asdfadsfasdfaa";
        var result = charCount(str);
        console.log("出现次数最多的字符是：" + result.character + "\n出现次数是：" + result.count);
```

### 去掉一组整形数组重复的值

```javascript
var arr = [1, 13, 24, 11, 11, 14, 1, 2];
        function removeRepeat(arr) {
            var newArr = [];
            for (var i = 0; i < arr.length; i++) {
                if (newArr.indexOf(arr[i]) == -1) {
                    newArr.push(arr[i]);
                }
            }
            return newArr;
        }
        console.log(removeRepeat(arr));
```

### 切换图片（点击小图显示对应大图）

```javascript
<div id="box">
    <div id="big"><img src="images/big/b1.jpg" alt=""></div>
	<div id="small">
        <div><img src="images/small/s1.jpg" alt=""></div>
        <div><img src="images/small/s2.jpg" alt=""></div>
        <div><img src="images/small/s3.jpg" alt=""></div>
        <div><img src="images/small/s4.jpg" alt=""></div>
	</div>
</div>
<script>
    var big = document.getElementById("big");
    var bigImg = big.getElementsByTagName("img")[0];
    var small = document.getElementById("small");
    var smallImg = small.getElementsByTagName("img");
    var curIdx = 0;     //定义初始显示图片的下标
    smallImg[curIdx].style.borderColor = "red";     //给图片加边框
	for (var i = 0; i < smallImg.length; i++) {
        smallImg[i].index = i;      //给图片添加属性index
        smallImg[i].onclick = function() {
            bigImg.src = this.src.replace("small/s", "big/b");  //replace   修改字符串里面的内容
            smallImg[curIdx].style.borderColor = "#ccc";    //让图片边框颜色返回之前的样式
            this.style.borderColor = "red";     //点击图片之后给当前被点击的图片设置边框颜色
            curIdx = this.index;    //记录当前点击的图片的下标，用于点击下个图片时清除本次图片的样式
        }
	}
</script>
```

i